<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Home · GenomePermutations.jl</title><script data-outdated-warner src="assets/warner.js"></script><link rel="canonical" href="https://sdangelis.github.io/GenomePermutations.jl/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href>GenomePermutations.jl</a></span></div><form class="docs-search" action="search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>Home</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Home</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Home</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/sdangelis/GenomePermutations.jl/blob/master/docs/src/index.md#" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="GenomePermutations"><a class="docs-heading-anchor" href="#GenomePermutations">GenomePermutations</a><a id="GenomePermutations-1"></a><a class="docs-heading-anchor-permalink" href="#GenomePermutations" title="Permalink"></a></h1><p>Documentation for <a href="https://github.com/sdangelis/GenomePermutations.jl">GenomePermutations</a>.</p><ul><li><a href="#GenomePermutations.PermTestResult"><code>GenomePermutations.PermTestResult</code></a></li><li><a href="#GenomePermutations.SimplePTest"><code>GenomePermutations.SimplePTest</code></a></li><li><a href="#GenomePermutations._randomgenome-Tuple{Any, Int64, Distributions.Categorical{P, Ps} where {P&lt;:Real, Ps&lt;:AbstractVector{P}}, Distributions.DiscreteDistribution, Vector{String}}"><code>GenomePermutations._randomgenome</code></a></li><li><a href="#GenomePermutations._randominterval-Union{Tuple{S}, Tuple{T}, Tuple{Interval{T}, Distributions.Sampleable, IntervalCollection{S}}} where {T, S}"><code>GenomePermutations._randominterval</code></a></li><li><a href="#GenomePermutations.alloverlapping-Union{Tuple{S}, Tuple{T}, Tuple{IntervalCollection{T}, IntervalCollection{S}}} where {T, S}"><code>GenomePermutations.alloverlapping</code></a></li><li><a href="#GenomePermutations.anyoverlapping-Union{Tuple{S}, Tuple{T}, Tuple{Interval{T}, IntervalCollection{S}}} where {T, S}"><code>GenomePermutations.anyoverlapping</code></a></li><li><a href="#GenomePermutations.countoverlapping-Union{Tuple{S}, Tuple{T}, Tuple{IntervalCollection{T}, IntervalCollection{S}}} where {T, S}"><code>GenomePermutations.countoverlapping</code></a></li><li><a href="#GenomePermutations.dist-Union{Tuple{S}, Tuple{T}, Tuple{Interval{T}, IntervalCollection{S}}, Tuple{Interval{T}, IntervalCollection{S}, Function}} where {T, S}"><code>GenomePermutations.dist</code></a></li><li><a href="#GenomePermutations.dist-Union{Tuple{T}, Tuple{S}, Tuple{Interval{S}, Interval{T}}} where {S, T}"><code>GenomePermutations.dist</code></a></li><li><a href="#GenomePermutations.dist-Union{Tuple{T}, Tuple{S}, Tuple{IntervalCollection{T}, IntervalCollection{S}}, Tuple{IntervalCollection{T}, IntervalCollection{S}, Function}, Tuple{IntervalCollection{T}, IntervalCollection{S}, Function, Function}} where {S, T}"><code>GenomePermutations.dist</code></a></li><li><a href="#GenomePermutations.generatedistribution-Tuple{Any}"><code>GenomePermutations.generatedistribution</code></a></li><li><a href="#GenomePermutations.isin-Union{Tuple{S}, Tuple{T}, Tuple{IntervalCollection{T}, IntervalCollection{S}}} where {T, S}"><code>GenomePermutations.isin</code></a></li><li><a href="#GenomePermutations.isin-Union{Tuple{T}, Tuple{S}, Tuple{Interval{S}, Interval{T}}} where {S, T}"><code>GenomePermutations.isin</code></a></li><li><a href="#GenomePermutations.isin-Union{Tuple{T}, Tuple{S}, Tuple{Interval{S}, IntervalCollection{T}}} where {S, T}"><code>GenomePermutations.isin</code></a></li><li><a href="#GenomePermutations.iter_getcollection-Union{Tuple{T}, Tuple{IntervalCollection{T}, String}} where T"><code>GenomePermutations.iter_getcollection</code></a></li><li><a href="#GenomePermutations.overlappermtest-NTuple{4, Any}"><code>GenomePermutations.overlappermtest</code></a></li><li><a href="#GenomePermutations.permtest"><code>GenomePermutations.permtest</code></a></li><li><a href="#GenomePermutations.randominterval-Union{Tuple{T}, Tuple{S}, Tuple{Interval{T}, Distributions.Sampleable, IntervalCollection{S}}} where {S, T}"><code>GenomePermutations.randominterval</code></a></li><li><a href="#GenomePermutations.randomisegenome-Union{Tuple{T}, Tuple{S}, Tuple{IntervalCollection{T}, IntervalCollection{S}}} where {S, T}"><code>GenomePermutations.randomisegenome</code></a></li><li><a href="#GenomePermutations.randomiseregions-Union{Tuple{S}, Tuple{T}, Tuple{IntervalCollection{T}, Distributions.Sampleable, IntervalCollection{S}}} where {T, S}"><code>GenomePermutations.randomiseregions</code></a></li><li><a href="#GenomePermutations.simpleP-Tuple{Any, Any, Any}"><code>GenomePermutations.simpleP</code></a></li><li><a href="#GenomePermutations.vec_getcollection-Tuple{Any, String}"><code>GenomePermutations.vec_getcollection</code></a></li><li><a href="#HypothesisTests.pvalue-Tuple{PermTestResult}"><code>HypothesisTests.pvalue</code></a></li><li><a href="#HypothesisTests.pvalue-Tuple{SimplePTest}"><code>HypothesisTests.pvalue</code></a></li></ul><article class="docstring"><header><a class="docstring-binding" id="GenomePermutations.PermTestResult" href="#GenomePermutations.PermTestResult"><code>GenomePermutations.PermTestResult</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">PermTestResult{S &lt;: Union{Real, Vector{&lt;:Real}}, N &lt;: Union{Real, Vector{&lt;:Real}}, T &lt;: Any}</code></pre><p>A structure to store results of any permutation test implements pvalue.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sdangelis/GenomePermutations.jl/blob/74677ae091792aef563101e2b38112184c4845ce/src/GenomePermutations.jl#L584-L589">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GenomePermutations.SimplePTest" href="#GenomePermutations.SimplePTest"><code>GenomePermutations.SimplePTest</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SimplePTest(iterations::Int, p_val::, alternative::)</code></pre><p>A structure to save RegioneR - style simple P tests. Implements <code>pvalue</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sdangelis/GenomePermutations.jl/blob/74677ae091792aef563101e2b38112184c4845ce/src/GenomePermutations.jl#L567-L571">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GenomePermutations._randomgenome-Tuple{Any, Int64, Distributions.Categorical{P, Ps} where {P&lt;:Real, Ps&lt;:AbstractVector{P}}, Distributions.DiscreteDistribution, Vector{String}}" href="#GenomePermutations._randomgenome-Tuple{Any, Int64, Distributions.Categorical{P, Ps} where {P&lt;:Real, Ps&lt;:AbstractVector{P}}, Distributions.DiscreteDistribution, Vector{String}}"><code>GenomePermutations._randomgenome</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">_randomgenome(regions, n, C, L, names; allow_overlap = false)</code></pre><p>Generates a new random genome with n segments from a named sequence distribution</p><p><strong>Arguments</strong></p><ul><li><code>regions</code>: the regions the genome to generate belongs to.</li><li><code>n::Int</code>: the number of segments to generate.</li><li><code>C::Distributions.Categorical</code>: a distibution with each cateogy representing</li></ul><p>one of the named sequences. Lenght and order must match names.</p><ul><li>`L::Distributions.DiscreteUniform&quot;: the segment lenght distribution.</li><li><code>names::Vector{Strimg}</code>: the names of the sequences. must match the categories in C.</li><li><code>allow_overlap::Bool = false</code>: whether to allow overlapping segments in the result.</li></ul><p>This is currently private as I have not tested this and I don&#39;t like the categorical distribution squence names situation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sdangelis/GenomePermutations.jl/blob/74677ae091792aef563101e2b38112184c4845ce/src/GenomePermutations.jl#L703-L721">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GenomePermutations._randominterval-Union{Tuple{S}, Tuple{T}, Tuple{Interval{T}, Distributions.Sampleable, IntervalCollection{S}}} where {T, S}" href="#GenomePermutations._randominterval-Union{Tuple{S}, Tuple{T}, Tuple{Interval{T}, Distributions.Sampleable, IntervalCollection{S}}} where {T, S}"><code>GenomePermutations._randominterval</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">_randominterval(interval::GenomicFeatures.Interval{T}, 
	distribution::Distributions.Sampleable, regions::GenomicFeatures.IntervalCollection{S};
	collection::GenomicFeatures.IntervalCollection{T} = GenomicFeatures.IntervalCollection{T}(), 
	allow_overlap::Bool = true, max_tries::Int = 1000) where {T, S}}</code></pre><p>This is the private version of randominterval, it skips sequence assertions in the name of performance Does it actually improve performance? Debeatable, in theory it prevents 100s of IFs. In practice, I haven&#39;t tested it.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sdangelis/GenomePermutations.jl/blob/74677ae091792aef563101e2b38112184c4845ce/src/GenomePermutations.jl#L351-L360">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GenomePermutations.alloverlapping-Union{Tuple{S}, Tuple{T}, Tuple{IntervalCollection{T}, IntervalCollection{S}}} where {T, S}" href="#GenomePermutations.alloverlapping-Union{Tuple{S}, Tuple{T}, Tuple{IntervalCollection{T}, IntervalCollection{S}}} where {T, S}"><code>GenomePermutations.alloverlapping</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">alloverlapping(a::GenomicFeatures.IntervalCollection{T}, b::GenomicFeatures.IntervalCollection{S})</code></pre><p>Linearly check if all intervals in collection a overlap collection b.  Return true or false</p><pre><code class="language-julia hljs">using GenomicFeatures 
a = GenomicFeatures.IntervalCollection([
	GenomicFeatures.Interval(&quot;chr1&quot;, 14, 17),
	GenomicFeatures.Interval(&quot;chr1&quot;, 20, 25)
	])
b = GenomicFeatures.IntervalCollection([
	GenomicFeatures.Interval(&quot;chr1&quot;, 5, 10),
	GenomicFeatures.Interval(&quot;chr1&quot;, 20, 25)
	])
alloverlapping(a, b) 
	
# output

false</code></pre><p>See Also <a href="#GenomePermutations.anyoverlapping-Union{Tuple{S}, Tuple{T}, Tuple{Interval{T}, IntervalCollection{S}}} where {T, S}"><code>GenomePermutations.anyoverlapping</code></a>, <a href="#GenomePermutations.countoverlapping-Union{Tuple{S}, Tuple{T}, Tuple{IntervalCollection{T}, IntervalCollection{S}}} where {T, S}"><code>GenomePermutations.countoverlapping</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sdangelis/GenomePermutations.jl/blob/74677ae091792aef563101e2b38112184c4845ce/src/GenomePermutations.jl#L48-L72">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GenomePermutations.anyoverlapping-Union{Tuple{S}, Tuple{T}, Tuple{Interval{T}, IntervalCollection{S}}} where {T, S}" href="#GenomePermutations.anyoverlapping-Union{Tuple{S}, Tuple{T}, Tuple{Interval{T}, IntervalCollection{S}}} where {T, S}"><code>GenomePermutations.anyoverlapping</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">anyoverlapping(a::GenomicFeatures.Interval{T},
b::GenomicFeatures.IntervalCollection{S})</code></pre><p>Extend GenomicFeatures.isoverlapping to linearly check if interval a. overlaps collection. Return true or false</p><pre><code class="language-julia hljs">using GenomicFeatures 
a = GenomicFeatures.Interval(&quot;chr1&quot;, 0, 10)
b = GenomicFeatures.IntervalCollection([
	GenomicFeatures.Interval(&quot;chr1&quot;, 5, 15),
	GenomicFeatures.Interval(&quot;chr1&quot;, 20, 25)
	])
anyoverlapping(a, b) 

# output

true</code></pre><p>See Also <a href="#GenomePermutations.alloverlapping-Union{Tuple{S}, Tuple{T}, Tuple{IntervalCollection{T}, IntervalCollection{S}}} where {T, S}"><code>GenomePermutations.alloverlapping</code></a>, <a href="#GenomePermutations.countoverlapping-Union{Tuple{S}, Tuple{T}, Tuple{IntervalCollection{T}, IntervalCollection{S}}} where {T, S}"><code>GenomePermutations.countoverlapping</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sdangelis/GenomePermutations.jl/blob/74677ae091792aef563101e2b38112184c4845ce/src/GenomePermutations.jl#L17-L39">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GenomePermutations.countoverlapping-Union{Tuple{S}, Tuple{T}, Tuple{IntervalCollection{T}, IntervalCollection{S}}} where {T, S}" href="#GenomePermutations.countoverlapping-Union{Tuple{S}, Tuple{T}, Tuple{IntervalCollection{T}, IntervalCollection{S}}} where {T, S}"><code>GenomePermutations.countoverlapping</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">countoverlapping(a::GenomicFeatures.IntervalCollection{T} , b::GenomicFeatures.IntervalCollection{T})</code></pre><p>Linearly count how many intervals in collection a overlap with collection b.</p><pre><code class="language-julia hljs">
using GenomicFeatures 
a = GenomicFeatures.IntervalCollection([
	GenomicFeatures.Interval(&quot;chr1&quot;, 14, 17),
	GenomicFeatures.Interval(&quot;chr1&quot;, 20, 50)
	])
b = GenomicFeatures.IntervalCollection([
	GenomicFeatures.Interval(&quot;chr1&quot;, 5, 10),
	GenomicFeatures.Interval(&quot;chr1&quot;, 25, 35 ),
	GenomicFeatures.Interval(&quot;chr1&quot;, 40, 65)
	])

[countoverlapping(a, b), countoverlapping(b, a)]

# output

2-element Vector{Int64}:
 1
 2</code></pre><p>#Note  As seen above, countoverlapping(a,b) != countoverlapping(b,a) as one interval in a  can overlap with &gt;1 intervals in b.</p><p>See Also <a href="#GenomePermutations.anyoverlapping-Union{Tuple{S}, Tuple{T}, Tuple{Interval{T}, IntervalCollection{S}}} where {T, S}"><code>GenomePermutations.anyoverlapping</code></a>, <a href="#GenomePermutations.alloverlapping-Union{Tuple{S}, Tuple{T}, Tuple{IntervalCollection{T}, IntervalCollection{S}}} where {T, S}"><code>GenomePermutations.alloverlapping</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sdangelis/GenomePermutations.jl/blob/74677ae091792aef563101e2b38112184c4845ce/src/GenomePermutations.jl#L111-L143">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GenomePermutations.dist-Union{Tuple{S}, Tuple{T}, Tuple{Interval{T}, IntervalCollection{S}}, Tuple{Interval{T}, IntervalCollection{S}, Function}} where {T, S}" href="#GenomePermutations.dist-Union{Tuple{S}, Tuple{T}, Tuple{Interval{T}, IntervalCollection{S}}, Tuple{Interval{T}, IntervalCollection{S}, Function}} where {T, S}"><code>GenomePermutations.dist</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">dist(a,b, f = minimum)</code></pre><p>Linearly calculate all the distances between an interval a and a collection b, return a value according to function f.</p><p><strong>Arguments</strong></p><ul><li><code>a::GenomicFeatures.interval{T}</code>: interval to calculate distances from.</li><li><code>b::GenomicFeatures.IntervalCollection{S}</code>: collection to calculate all distances to.</li><li><code>f::Function</code>: f Summarise all the pairwise distance for a and each interval in b </li></ul><p>according to the supplied function f  Currently tested with <code>minimum</code>, <code>maximum</code>, <code>mean</code>, and <code>median</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sdangelis/GenomePermutations.jl/blob/74677ae091792aef563101e2b38112184c4845ce/src/GenomePermutations.jl#L247-L260">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GenomePermutations.dist-Union{Tuple{T}, Tuple{S}, Tuple{IntervalCollection{T}, IntervalCollection{S}}, Tuple{IntervalCollection{T}, IntervalCollection{S}, Function}, Tuple{IntervalCollection{T}, IntervalCollection{S}, Function, Function}} where {S, T}" href="#GenomePermutations.dist-Union{Tuple{T}, Tuple{S}, Tuple{IntervalCollection{T}, IntervalCollection{S}}, Tuple{IntervalCollection{T}, IntervalCollection{S}, Function}, Tuple{IntervalCollection{T}, IntervalCollection{S}, Function, Function}} where {S, T}"><code>GenomePermutations.dist</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">dist(a, b, f, g)</code></pre><p>Lineraly caluclates the distance between collection a and b. Each distance between a and b is summarised according to f and then summarised  according to g.</p><p><strong>Agruments</strong></p><ul><li><code>a::GenomicFeatures.IntervalCollection{T}</code>: collection a.</li><li><code>b::GenomicFeatures.IntervalCollection{S}</code>: collectionb b.</li><li><code>f::Function = x -&gt; x</code>: f summarisees the result of the distances </li></ul><p>between each interval of a and all intervals in b.  tested with <code>minimum</code>. &#39;maximum<code>,</code>mean<code>,</code>median`</p><ul><li><code>g::Function = minimum</code>: g summarises the distances returned by f for all</li></ul><p>items in a. Currently tested with <code>minimum</code>. <code>maximum</code>, <code>mean</code>, and <code>median</code>.</p><p><strong>Note</strong></p><p>Both g and f can be replaced by user-defined functions. f must take a   Vector{Union{Int, Float64}} and return Union{Int, Float64}. g must take a Vector{Union{Int, Float64}} but can return any type. Due to the fact that the result of f is stored in d before being summarised, it  is not possible to change f&#39;s return type  - even if we use a function in g that could acept a vector of that type. Indeed this is the reason for the need to Union{Int}</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sdangelis/GenomePermutations.jl/blob/74677ae091792aef563101e2b38112184c4845ce/src/GenomePermutations.jl#L278-L304">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GenomePermutations.dist-Union{Tuple{T}, Tuple{S}, Tuple{Interval{S}, Interval{T}}} where {S, T}" href="#GenomePermutations.dist-Union{Tuple{T}, Tuple{S}, Tuple{Interval{S}, Interval{T}}} where {S, T}"><code>GenomePermutations.dist</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">dist(a, b)</code></pre><p>Return the minimum unsigend distance between Intervals a and b. returns missing if the two intervals do not have the same seqname. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sdangelis/GenomePermutations.jl/blob/74677ae091792aef563101e2b38112184c4845ce/src/GenomePermutations.jl#L234-L239">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GenomePermutations.generatedistribution-Tuple{Any}" href="#GenomePermutations.generatedistribution-Tuple{Any}"><code>GenomePermutations.generatedistribution</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">generatedistribution(collection)</code></pre><p>Generate a Distributions.MixtureModel from the collection </p><p>The model assumes each position of the genome has equal probability of being sampled. Practically, it is modelled as a mixture model of individual discrete uniform distributions, one for each interval in the collection. The component distributions are distribuited according to a categorical distribution, with  probabilities proportional to the length of each interval.</p><p><strong>Note</strong></p><p>At the moment it only supports collections with single sequence. Generating a distribution from an overlapping collection is undocumented (I assume it would add up the probability but this is untested)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sdangelis/GenomePermutations.jl/blob/74677ae091792aef563101e2b38112184c4845ce/src/GenomePermutations.jl#L321-L337">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GenomePermutations.isin-Union{Tuple{S}, Tuple{T}, Tuple{IntervalCollection{T}, IntervalCollection{S}}} where {T, S}" href="#GenomePermutations.isin-Union{Tuple{S}, Tuple{T}, Tuple{IntervalCollection{T}, IntervalCollection{S}}} where {T, S}"><code>GenomePermutations.isin</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">isin(a:::GenomicFeatures.IntervalCollection{T}, b:::GenomicFeatures.IntervalCollection{S})</code></pre><p>Linearly check if all intervals in collection a are contained in collection b. </p><p><strong>Note</strong></p><p>At this point there are 2 layers of linear search so the time complexity is n^2.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sdangelis/GenomePermutations.jl/blob/74677ae091792aef563101e2b38112184c4845ce/src/GenomePermutations.jl#L215-L223">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GenomePermutations.isin-Union{Tuple{T}, Tuple{S}, Tuple{Interval{S}, IntervalCollection{T}}} where {S, T}" href="#GenomePermutations.isin-Union{Tuple{T}, Tuple{S}, Tuple{Interval{S}, IntervalCollection{T}}} where {S, T}"><code>GenomePermutations.isin</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">isin(a::GenomicFeatures.Interval{T}, b::GenomicFeatures.IntervalCollection{S})</code></pre><p>Linearly check if interval a is fully contained in collection b.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sdangelis/GenomePermutations.jl/blob/74677ae091792aef563101e2b38112184c4845ce/src/GenomePermutations.jl#L200-L204">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GenomePermutations.isin-Union{Tuple{T}, Tuple{S}, Tuple{Interval{S}, Interval{T}}} where {S, T}" href="#GenomePermutations.isin-Union{Tuple{T}, Tuple{S}, Tuple{Interval{S}, Interval{T}}} where {S, T}"><code>GenomePermutations.isin</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">isin(a::GenomicFeatures.Interval{S}, GenomicFeatures.Interval{T})</code></pre><p>Check if interval a is fully contained in interval b.</p><pre><code class="language-julia hljs">using GenomicFeatures 
a = GenomicFeatures.Interval(&quot;chr1&quot;, 5, 10)
b = GenomicFeatures.Interval(&quot;chr1&quot;, 1, 15)

isin(a, b) 
	
# output

true</code></pre><pre><code class="language-julia hljs">using GenomicFeatures 
a = GenomicFeatures.Interval(&quot;chr1&quot;, 20, 30)
b = GenomicFeatures.Interval(&quot;chr1&quot;, 1, 15)

isin(a, b) 
	
# output

false</code></pre><pre><code class="language-julia hljs">using GenomicFeatures 
a = GenomicFeatures.Interval(&quot;chr1&quot;, 10, 20)
b = GenomicFeatures.Interval(&quot;chr1&quot;, 1, 15)

isin(a, b) 
	
# output

false</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sdangelis/GenomePermutations.jl/blob/74677ae091792aef563101e2b38112184c4845ce/src/GenomePermutations.jl#L154-L194">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GenomePermutations.iter_getcollection-Union{Tuple{T}, Tuple{IntervalCollection{T}, String}} where T" href="#GenomePermutations.iter_getcollection-Union{Tuple{T}, Tuple{IntervalCollection{T}, String}} where T"><code>GenomePermutations.iter_getcollection</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">iter_getcollection(collection::GenomicFeatures.IntervalCollection{T}, sequence::String)</code></pre><p>(inefficiently) retun a interval collection with only features in the specified sequence.</p><p>see also <a href="#GenomePermutations.vec_getcollection-Tuple{Any, String}"><code>GenomePermutations.vec_getcollection</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sdangelis/GenomePermutations.jl/blob/74677ae091792aef563101e2b38112184c4845ce/src/GenomePermutations.jl#L94-L100">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GenomePermutations.overlappermtest-NTuple{4, Any}" href="#GenomePermutations.overlappermtest-NTuple{4, Any}"><code>GenomePermutations.overlappermtest</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">overlappermtest(col1, col2, regions, iterations; bed_names, allow_overlap = false,
max_tries = 1000, onfail = :throws)</code></pre><p>Legacy function to run an overlap permutation test across 2 regions. will be replaced by <code>permtest</code> using countoverlapping as <code>f</code> argument. Will need a <code>g</code> function to summarise overlaps across regions. (likely <code>sum</code>).</p><p><strong>Arguments</strong></p><ul><li><code>col1::GenomicFeatures.IntervalCollection{T}</code>: the collection to randomise.</li><li><code>col2::GenomicFeatures.IntervalCollection{S}</code>: the constant collection to test.</li><li><code>regions::GenomicFeatures.IntervalCollection{S}</code>: the regions col1 is randomised in.</li><li><code>iterations::Int</code>: the number of iterations to run.</li><li><code>bed_names::Union{String, Nothing}</code>: the names of the bed files to write to.</li><li><code>allow_overlap::Bool = false</code>: whether to allow overlaps in the randomised regions.</li><li><code>max_tries::Int</code>: the maximum number of tries to generate a randomised collection.</li><li><code>onfail::Symbol = :throw</code>: what to do if the new random interval fails to fit in the region.</li></ul><p>Will return the orignal interval if :orig, otherwise throws an error.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sdangelis/GenomePermutations.jl/blob/74677ae091792aef563101e2b38112184c4845ce/src/GenomePermutations.jl#L623-L642">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GenomePermutations.permtest" href="#GenomePermutations.permtest"><code>GenomePermutations.permtest</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">permtest(col1, col2, regions, iterations, f; allow_overlap = false, max_tries::Int = 1000, onfail = :throw)</code></pre><p>Runs a flexible permuation test, using a custsom evaluation function <code>f</code>.</p><p><strong>Arguments</strong></p><ul><li><code>col1::GenomicFeatures.IntervalCollection{}</code>: the collection to randomise.</li><li><code>col2::GenomicFeatures.IntervalCollection{}</code>: the constant collection to test.</li><li><code>regions::GenomicFeatures.IntervalCollection{}</code>: the regions col1 is randomised in.</li><li><code>iterations::Int</code>: the number of iterations to run.</li><li><code>f::Function = GenomePermutations.dist</code>: the evaluation function. </li></ul><p>Defaults to GenomePermutations.dist.</p><ul><li><code>bed_names::Union{String, Nothing}</code>: the names of the bed files to write to.</li><li><code>allow_overlap::Bool = false</code>: whether to allow overlaps in the randomised regions.</li><li><code>max_tries::Int = 1000</code>: the maximum number of tries to generate a randomised collection.</li><li><code>onfail::Symbol = :throw</code>: what to do if the new random interval fails to fit in the region.</li></ul><p>Will return the orignal interval if :orig, otherwise (i.e <code>:throw</code>) throws an error.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sdangelis/GenomePermutations.jl/blob/74677ae091792aef563101e2b38112184c4845ce/src/GenomePermutations.jl#L743-L761">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GenomePermutations.randominterval-Union{Tuple{T}, Tuple{S}, Tuple{Interval{T}, Distributions.Sampleable, IntervalCollection{S}}} where {S, T}" href="#GenomePermutations.randominterval-Union{Tuple{T}, Tuple{S}, Tuple{Interval{T}, Distributions.Sampleable, IntervalCollection{S}}} where {S, T}"><code>GenomePermutations.randominterval</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">randominterval(interval, distribution, regions, collection; allow_overlap, max_tries)</code></pre><p>Randomises the position of an interval according to a given distribution. </p><p><strong>Arguments</strong></p><ul><li><code>interval::GenomicFeatures.IntervalCollection</code>: The interval to randomise</li><li><code>distribution::Distributions.Sampleable</code>: distribution of possible interval start location.</li></ul><p>Should be a discrete distribution, although right now this is not enforced at the signature level</p><ul><li><code>regions::</code>: the regions the new interval should be fully contained in (checked by<code>isin</code>)</li><li><code>collecton::GenomicFeatures.IntervalCollection =</code>: Collection to avoid overlapping </li></ul><p>to if allow_overlap is set to false, defaults to an empty collection of metadata T.</p><ul><li><code>allow_overlap::Bool = true</code>: whether to allow overlaps to collection.</li><li><code>max_tries::Int = 1000</code>: the maximum number of attempts to draw an interval that fits in</li></ul><p>the region from the distribution</p><ul><li><code>onfail::Symbol = :throw</code>: what to do if the interval fails to fit in the region.</li></ul><p>Will return the orignal nterval if :orig, otherwise throws an error.</p><p><strong>Note</strong></p><p>To prevent intervals in a loop from overlapping each other, use  <code>allow_overlap = false</code> and add the result of each iteration to the collection paseed to the function.</p><p>See Also (_randominterval)[@ref]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sdangelis/GenomePermutations.jl/blob/74677ae091792aef563101e2b38112184c4845ce/src/GenomePermutations.jl#L391-L418">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GenomePermutations.randomisegenome-Union{Tuple{T}, Tuple{S}, Tuple{IntervalCollection{T}, IntervalCollection{S}}} where {S, T}" href="#GenomePermutations.randomisegenome-Union{Tuple{T}, Tuple{S}, Tuple{IntervalCollection{T}, IntervalCollection{S}}} where {S, T}"><code>GenomePermutations.randomisegenome</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">randomisegenome(col, regions; allow_overlap, max_tries)</code></pre><p>Randomises a collection, sequence by sequence along the specified regions, returning the new collection</p><p><strong>rguments</strong></p><ul><li><code>col::GenomicFeatrues.IntervalCollection{T}</code>: collection to randomise</li><li><code>regions::GenomicFeatures.IntervalCollection{S}</code>: regions to randomise the collection in.</li><li><code>allow_overlap::Bool = false</code>: whether to allow overlapping intervals in the result.</li><li><code>max_tries::Int = 1000</code>: maximum number of attempts to draw an interval</li></ul><p>that fits in the regions.</p><ul><li><code>onfail::Symbol = :throw</code>: what to do if the interval fails to fit in the regions.</li></ul><p>Will return the orignal nterval if :orig, otherwise throws an error.</p><p>Note: it will skip any sequences in the collection not found in the target regions. If no sequences are found returns an empty collection.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sdangelis/GenomePermutations.jl/blob/74677ae091792aef563101e2b38112184c4845ce/src/GenomePermutations.jl#L479-L496">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GenomePermutations.randomiseregions-Union{Tuple{S}, Tuple{T}, Tuple{IntervalCollection{T}, Distributions.Sampleable, IntervalCollection{S}}} where {T, S}" href="#GenomePermutations.randomiseregions-Union{Tuple{S}, Tuple{T}, Tuple{IntervalCollection{T}, Distributions.Sampleable, IntervalCollection{S}}} where {T, S}"><code>GenomePermutations.randomiseregions</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">randomiseregions(collection, distribution, regions; allow_overlap, max_tries, onfail)</code></pre><p>Generates randomised regions from an interval collection according to a start postion distribution. It guarantees that the new intervals are contained in the given regions.</p><p><strong>Arguments</strong></p><ul><li><code>collection::GenomicFeatures.IntervalCollection{T}</code>: collection to randomise,</li></ul><p>must have only 1 sequence.</p><ul><li><code>distribution::Distributions.Sampleable</code>: distribution of possible interval</li></ul><p>start locations, must match collection.</p><ul><li><code>regions::GenomicFeatures.IntervalCollection{S}</code>: regions to randomise the intervals in.</li><li>`allow_overlap::Bool = false.</li><li><code>max_tries::Int = 1000</code>: maximum number of attempts to draw an interval</li></ul><p>that fits in the region from the distribution.</p><ul><li><code>onfail::Symbol = :throw</code>: what to do if the interval fails to fit in the region.</li></ul><p>Will return the orignal nterval if :orig, otherwise throws an error.</p><p><strong>Notes</strong></p><p>this functions assumes that the interval collection contains intervals belonging  to a single sequence that is the same sequence used for the distribution.  The distribution should be derived from the regions, else the randomiser will (safely) fail New intervals overlapping with other intervals in the nascient collection are disallowed by default. To allow overlaps use `allow_overlap = true</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sdangelis/GenomePermutations.jl/blob/74677ae091792aef563101e2b38112184c4845ce/src/GenomePermutations.jl#L439-L465">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GenomePermutations.simpleP-Tuple{Any, Any, Any}" href="#GenomePermutations.simpleP-Tuple{Any, Any, Any}"><code>GenomePermutations.simpleP</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">simpleP(obs, ran, iterations; alternative :Auto)</code></pre><p>Calculates the p value for the alternative hypothesis that the observed value is either more or less than what we expect from the Vecor of random values.</p><p>If no altrantive is provided, will be automatically selected  on the basis of the data.</p><p>See also: <a href="https://doi.org/doi:10.18129/B9.bioc.regioneR">regioneR</a>, <a href="#GenomePermutations.SimplePTest"><code>SimplePTest</code></a> Please see regioneR for full details</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sdangelis/GenomePermutations.jl/blob/74677ae091792aef563101e2b38112184c4845ce/src/GenomePermutations.jl#L538-L549">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GenomePermutations.vec_getcollection-Tuple{Any, String}" href="#GenomePermutations.vec_getcollection-Tuple{Any, String}"><code>GenomePermutations.vec_getcollection</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">vec_getcollection(collection::GenomicFeatures.IntervalCollection{T}, sequence::String)</code></pre><p>(inefficiently) retun a interval collection with only features in the specified sequence </p><p>See Also <a href="#GenomePermutations.iter_getcollection-Union{Tuple{T}, Tuple{IntervalCollection{T}, String}} where T"><code>GenomePermutations.iter_getcollection</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sdangelis/GenomePermutations.jl/blob/74677ae091792aef563101e2b38112184c4845ce/src/GenomePermutations.jl#L81-L87">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HypothesisTests.pvalue-Tuple{PermTestResult}" href="#HypothesisTests.pvalue-Tuple{PermTestResult}"><code>HypothesisTests.pvalue</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">HypothesisTests.pvalue(test::GenomePermutations.PermTestResult)</code></pre><p>Extends HypothesisTests.pvalue to get the P value of a GenomePermutations.PermTestResult.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sdangelis/GenomePermutations.jl/blob/74677ae091792aef563101e2b38112184c4845ce/src/GenomePermutations.jl#L603-L607">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HypothesisTests.pvalue-Tuple{SimplePTest}" href="#HypothesisTests.pvalue-Tuple{SimplePTest}"><code>HypothesisTests.pvalue</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">HypothesisTests.pvalue(test::GenomePermutations.SimplePTest)</code></pre><p>Extends HypothesisTests.pvalue to get the P value of a GenomePermutations.SimplePTest.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sdangelis/GenomePermutations.jl/blob/74677ae091792aef563101e2b38112184c4845ce/src/GenomePermutations.jl#L613-L617">source</a></section></article></article><nav class="docs-footer"><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.13 on <span class="colophon-date" title="Tuesday 5 April 2022 17:29">Tuesday 5 April 2022</span>. Using Julia version 1.7.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
