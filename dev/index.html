<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Home · GenomePermutations.jl</title><script data-outdated-warner src="assets/warner.js"></script><link rel="canonical" href="https://sdangelis.github.io/GenomePermutations.jl/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href>GenomePermutations.jl</a></span></div><form class="docs-search" action="search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>Home</a><ul class="internal"><li><a class="tocitem" href="#Index"><span>Index</span></a></li><li><a class="tocitem" href="#Introduction"><span>Introduction</span></a></li><li><a class="tocitem" href="#Quick-Start-and-Vignette"><span>Quick Start and Vignette</span></a></li><li><a class="tocitem" href="#Checking-if-intervals-are-in-a-collection"><span>Checking if intervals are in a collection</span></a></li><li><a class="tocitem" href="#Overlap-calculations"><span>Overlap calculations</span></a></li><li><a class="tocitem" href="#Distance-calculations"><span>Distance calculations</span></a></li><li><a class="tocitem" href="#Genome-Distributions"><span>Genome Distributions</span></a></li><li><a class="tocitem" href="#Permutation-tests"><span>Permutation tests</span></a></li><li><a class="tocitem" href="#Extending-Genome-Permutations"><span>Extending Genome Permutations</span></a></li><li><a class="tocitem" href="#Legacy-Functions"><span>Legacy Functions</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Home</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Home</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/sdangelis/GenomePermutations.jl/blob/master/docs/src/index.md#" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="GenomePermutations"><a class="docs-heading-anchor" href="#GenomePermutations">GenomePermutations</a><a id="GenomePermutations-1"></a><a class="docs-heading-anchor-permalink" href="#GenomePermutations" title="Permalink"></a></h1><p>Documentation for <a href="https://github.com/sdangelis/GenomePermutations.jl">GenomePermutations</a>.</p><h2 id="Index"><a class="docs-heading-anchor" href="#Index">Index</a><a id="Index-1"></a><a class="docs-heading-anchor-permalink" href="#Index" title="Permalink"></a></h2><ul><li><a href="#GenomePermutations.AbstractGenomeDist"><code>GenomePermutations.AbstractGenomeDist</code></a></li><li><a href="#GenomePermutations.AdaptiveRegions"><code>GenomePermutations.AdaptiveRegions</code></a></li><li><a href="#GenomePermutations.CircularRandomiser"><code>GenomePermutations.CircularRandomiser</code></a></li><li><a href="#GenomePermutations.PermTestResult"><code>GenomePermutations.PermTestResult</code></a></li><li><a href="#GenomePermutations.RegionRandomiser"><code>GenomePermutations.RegionRandomiser</code></a></li><li><a href="#GenomePermutations.SimplePTest"><code>GenomePermutations.SimplePTest</code></a></li><li><a href="#GenomePermutations.StartMixture"><code>GenomePermutations.StartMixture</code></a></li><li><a href="#GenomePermutations.lengthsMixture"><code>GenomePermutations.lengthsMixture</code></a></li><li><a href="#Base.rand-Tuple{AbstractGenomeDist, Int64}"><code>Base.rand</code></a></li><li><a href="#GenomePermutations._loopdist"><code>GenomePermutations._loopdist</code></a></li><li><a href="#GenomePermutations._randomgenome"><code>GenomePermutations._randomgenome</code></a></li><li><a href="#GenomePermutations._randominterval"><code>GenomePermutations._randominterval</code></a></li><li><a href="#GenomePermutations.alloverlapping"><code>GenomePermutations.alloverlapping</code></a></li><li><a href="#GenomePermutations.anyin"><code>GenomePermutations.anyin</code></a></li><li><a href="#GenomePermutations.anyoverlapping"><code>GenomePermutations.anyoverlapping</code></a></li><li><a href="#GenomePermutations.countoverlapping"><code>GenomePermutations.countoverlapping</code></a></li><li><a href="#GenomePermutations.countoverlaps"><code>GenomePermutations.countoverlaps</code></a></li><li><a href="#GenomePermutations.dist"><code>GenomePermutations.dist</code></a></li><li><a href="#GenomePermutations.featuredist"><code>GenomePermutations.featuredist</code></a></li><li><a href="#GenomePermutations.generatedistribution"><code>GenomePermutations.generatedistribution</code></a></li><li><a href="#GenomePermutations.isin"><code>GenomePermutations.isin</code></a></li><li><a href="#GenomePermutations.iter_getcollection"><code>GenomePermutations.iter_getcollection</code></a></li><li><a href="#GenomePermutations.overlappermtest"><code>GenomePermutations.overlappermtest</code></a></li><li><a href="#GenomePermutations.permtest-Tuple{IntervalCollection, IntervalCollection, AbstractGenomeDist, Int64}"><code>GenomePermutations.permtest</code></a></li><li><a href="#GenomePermutations.permtest-Tuple{IntervalCollection, IntervalCollection, IntervalCollection, Int64}"><code>GenomePermutations.permtest</code></a></li><li><a href="#GenomePermutations.randominterval"><code>GenomePermutations.randominterval</code></a></li><li><a href="#GenomePermutations.randomise-Tuple{IntervalCollection, AbstractGenomeDist}"><code>GenomePermutations.randomise</code></a></li><li><a href="#GenomePermutations.randomisegenome"><code>GenomePermutations.randomisegenome</code></a></li><li><a href="#GenomePermutations.randomiseregions"><code>GenomePermutations.randomiseregions</code></a></li><li><a href="#GenomePermutations.simpleP"><code>GenomePermutations.simpleP</code></a></li><li><a href="#GenomePermutations.vec_getcollection"><code>GenomePermutations.vec_getcollection</code></a></li><li><a href="#HypothesisTests.pvalue-Tuple{PermTestResult}"><code>HypothesisTests.pvalue</code></a></li><li><a href="#HypothesisTests.pvalue-Tuple{SimplePTest}"><code>HypothesisTests.pvalue</code></a></li></ul><h2 id="Introduction"><a class="docs-heading-anchor" href="#Introduction">Introduction</a><a id="Introduction-1"></a><a class="docs-heading-anchor-permalink" href="#Introduction" title="Permalink"></a></h2><p>Often we require to calculate how far or how many overlaps a series of genomic locations have with a set of predetermined features. We can naively compare our sample with other samples or a range of randomly selected locations along the genome. However, the distribution of overlaps or distances depends on the lengths of the intervals</p><p>Permutation tests, where we shuffle random regions to a create a random null distribution can provide a probabilistic framework. By generating a null distribution from intervals of  the same length and distribution as what we observe, we can examine the location of  our observation in the distribution to see how likely our value was due to chance alone.</p><p>GenomePermutations is an higher-performance - although there is still lots of space for optimization -   opinionated Julia reimplementation of the permutation approach of <a href="http://bioconductor.org/packages/release/bioc/html/regioneR.html">RegioneR</a> that aims to improve ease of use, composability and performance without sacrificing statistical rigor.</p><p>GenomePermutations package is designed with composability in mind: There are 2 main steps in running a permutation test</p><ul><li>instantiate a GenomeDistribution type, subtype of AbstractGenomeDist, which contains both the regions,  the new distribution and defines methods to draw random samples</li><li>define a distance function - sensible defaults are provided</li><li>run a permutation test.</li></ul><h2 id="Quick-Start-and-Vignette"><a class="docs-heading-anchor" href="#Quick-Start-and-Vignette">Quick Start and Vignette</a><a id="Quick-Start-and-Vignette-1"></a><a class="docs-heading-anchor-permalink" href="#Quick-Start-and-Vignette" title="Permalink"></a></h2><p>inspired by R&#39;s vignettes, this section will introduce a complete workflow, from loading bed files, to running the permutation test and visualizing the output</p><p>At the moment this is an unregistered package, so we need to provide a GitHub link to manually install it. </p><p>Note this will install from the main </p><pre><code class="language-Julia hljs">using Pkg

Pkg.add(url=&quot;TBD&quot;)</code></pre><p>if you want the nightly, most unstable and up to date you&#39;ll have to install from the <code>dev</code> branch</p><p>We then load our BED files with <code>BED.jl</code></p><pre><code class="language-Julia hljs">using GenomePermutations 
using BED
using plots

CNAs =  open(BED.Reader, &quot;CNAs.bed&quot;) do reader
    IntervalCollection(reader, true)
end

features =  open(BED.Reader, &quot;features.bed&quot;) do reader
    IntervalCollection(reader, true)
end

regions =  open(BED.Reader, &quot;regions.bed&quot;) do reader
    IntervalCollection(reader, true)
end</code></pre><p>Calculating distances:</p><pre><code class="language-Julia hljs">distances = dist(CNAs, features)</code></pre><p>Generating a genome distributions:</p><pre><code class="language-Julia hljs">dist = GenomePermutations.StartMixture(&quot;hgTest&quot;, regions, false)</code></pre><p>Running a permutation test:</p><pre><code class="language-Julia hljs">test = permtest(CNAs,  features, dist, 1000)

# get the P value
pvalue(test.test)

histogram(test.ran, bins = :scott, color_palette=[&quot;grey75&quot;]) # Ok, not the prettiest but it can fly for now</code></pre><h2 id="Checking-if-intervals-are-in-a-collection"><a class="docs-heading-anchor" href="#Checking-if-intervals-are-in-a-collection">Checking if intervals are in a collection</a><a id="Checking-if-intervals-are-in-a-collection-1"></a><a class="docs-heading-anchor-permalink" href="#Checking-if-intervals-are-in-a-collection" title="Permalink"></a></h2><p>These functions extend functions in GenomicFeatures to check if collections are contained  in intervals or vice versa.</p><article class="docstring"><header><a class="docstring-binding" id="GenomePermutations.isin" href="#GenomePermutations.isin"><code>GenomePermutations.isin</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">isin(a::GenomicFeatures.Interval{S}, GenomicFeatures.Interval{T})</code></pre><p>Check if interval a is fully contained in interval b.</p><pre><code class="language-julia hljs">using GenomicFeatures 
a = GenomicFeatures.Interval(&quot;chr1&quot;, 5, 10)
b = GenomicFeatures.Interval(&quot;chr1&quot;, 1, 15)

isin(a, b) 
	
# output

true</code></pre><pre><code class="language-julia hljs">using GenomicFeatures 
a = GenomicFeatures.Interval(&quot;chr1&quot;, 20, 30)
b = GenomicFeatures.Interval(&quot;chr1&quot;, 1, 15)

isin(a, b) 
	
# output

false</code></pre><pre><code class="language-julia hljs">using GenomicFeatures 
a = GenomicFeatures.Interval(&quot;chr1&quot;, 10, 20)
b = GenomicFeatures.Interval(&quot;chr1&quot;, 1, 15)

isin(a, b) 
	
# output

false</code></pre><p>See Also <a href="#GenomePermutations.isin"><code>GenomePermutations.isin</code></a>, <a href="#GenomePermutations.anyin"><code>GenomePermutations.anyin</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sdangelis/GenomePermutations.jl/blob/f21541e71e327d8d7cca592a9a709520d091044a/src/Overlaps.jl#L161-L203">source</a></section><section><div><pre><code class="nohighlight hljs">isin(a::GenomicFeatures.Interval{T}, b::GenomicFeatures.IntervalCollection{S})</code></pre><p>Linearly check if interval a is fully contained in any interval of collection b.</p><pre><code class="language-julia hljs">using GenomicFeatures 
a = GenomicFeatures.Interval(&quot;chr1&quot;, 5, 10)
b = GenomicFeatures.IntervalCollection([
	GenomicFeatures.Interval(&quot;chr1&quot;, 5, 10),
	GenomicFeatures.Interval(&quot;chr1&quot;, 25, 35 ),
	GenomicFeatures.Interval(&quot;chr1&quot;, 40, 65)
	])

isin(a, b) 
		
# output

true</code></pre><pre><code class="language-julia hljs">using GenomicFeatures 
a = GenomicFeatures.Interval(&quot;chr1&quot;, 30, 50)
b = GenomicFeatures.IntervalCollection([
	GenomicFeatures.Interval(&quot;chr1&quot;, 5, 10),
	GenomicFeatures.Interval(&quot;chr1&quot;, 25, 35),
	GenomicFeatures.Interval(&quot;chr1&quot;, 35, 65)
	])

isin(a, b) 
		
# output

false</code></pre><p>#Note </p><p><code>isin(a, b)</code> strictly checks if a is contained in any single interval of b,  rather than whether a is contained within any combination of intervals in collection b</p><p>See Also <a href="#GenomePermutations.isin"><code>GenomePermutations.isin</code></a>, <a href="#GenomePermutations.anyin"><code>GenomePermutations.anyin</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sdangelis/GenomePermutations.jl/blob/f21541e71e327d8d7cca592a9a709520d091044a/src/Overlaps.jl#L209-L252">source</a></section><section><div><pre><code class="nohighlight hljs">isin(a:::GenomicFeatures.IntervalCollection{T}, b:::GenomicFeatures.IntervalCollection{S})</code></pre><p>Linearly check if <em>all</em> intervals in collection a are contained in collection b. </p><p>```jldoctest</p><pre><code class="nohighlight hljs">using GenomicFeatures 
a = GenomicFeatures.IntervalCollection([
	GenomicFeatures.Interval(&quot;chr1&quot;, 6, 9),
	GenomicFeatures.Interval(&quot;chr1&quot;, 45, 50)
	])
b = GenomicFeatures.IntervalCollection([
	GenomicFeatures.Interval(&quot;chr1&quot;, 5, 10),
	GenomicFeatures.Interval(&quot;chr1&quot;, 25, 35 ),
	GenomicFeatures.Interval(&quot;chr1&quot;, 40, 65)
	])

[isin(a, b), isin(b, a)]

# output

2-element Vector{Bool}:
 true
 false
```</code></pre><p><strong>Note</strong></p><p>At this point there are 2 layers of linear search so the time complexity is n^2.</p><p>See Also <a href="#GenomePermutations.isin"><code>GenomePermutations.isin</code></a>, <a href="#GenomePermutations.anyin"><code>GenomePermutations.anyin</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sdangelis/GenomePermutations.jl/blob/f21541e71e327d8d7cca592a9a709520d091044a/src/Overlaps.jl#L263-L295">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GenomePermutations.anyin" href="#GenomePermutations.anyin"><code>GenomePermutations.anyin</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">anyin(a:::GenomicFeatures.IntervalCollection{T}, b:::GenomicFeatures.IntervalCollection{S})</code></pre><p>Linearly check if <em>any</em> interval in collection a are contained in collection b. </p><pre><code class="language-julia hljs">
using GenomicFeatures 
a = GenomicFeatures.IntervalCollection([
	GenomicFeatures.Interval(&quot;chr1&quot;, 25, 27),
	GenomicFeatures.Interval(&quot;chr1&quot;, 100, 150)
	])
b = GenomicFeatures.IntervalCollection([
	GenomicFeatures.Interval(&quot;chr1&quot;, 5, 10),
	GenomicFeatures.Interval(&quot;chr1&quot;, 25, 35 ),
	GenomicFeatures.Interval(&quot;chr1&quot;, 40, 65)
	])
	
anyin(a, b)
	
# output

true</code></pre><p><strong>Note</strong></p><p>At this point there are 2 layers of linear search so the time complexity is n^2</p><p>See Also <a href="#GenomePermutations.isin"><code>GenomePermutations.isin</code></a>, <a href="#GenomePermutations.anyin"><code>GenomePermutations.anyin</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sdangelis/GenomePermutations.jl/blob/f21541e71e327d8d7cca592a9a709520d091044a/src/Overlaps.jl#L305-L335">source</a></section></article><h2 id="Overlap-calculations"><a class="docs-heading-anchor" href="#Overlap-calculations">Overlap calculations</a><a id="Overlap-calculations-1"></a><a class="docs-heading-anchor-permalink" href="#Overlap-calculations" title="Permalink"></a></h2><p>GenomePermutations contains functions to calculate overlaps between intervals and/or collections</p><article class="docstring"><header><a class="docstring-binding" id="GenomePermutations.anyoverlapping" href="#GenomePermutations.anyoverlapping"><code>GenomePermutations.anyoverlapping</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">anyoverlapping(a::GenomicFeatures.Interval{T},
b::GenomicFeatures.IntervalCollection{S})</code></pre><p>Extend GenomicFeatures.isoverlapping to linearly check if interval a. overlaps collection. Return true or false</p><pre><code class="language-julia hljs">using GenomicFeatures 
a = GenomicFeatures.Interval(&quot;chr1&quot;, 0, 10)
b = GenomicFeatures.IntervalCollection([
	GenomicFeatures.Interval(&quot;chr1&quot;, 5, 15),
	GenomicFeatures.Interval(&quot;chr1&quot;, 20, 25)
	])
anyoverlapping(a, b) 

# output

true</code></pre><p>See Also <a href="#GenomePermutations.alloverlapping"><code>GenomePermutations.alloverlapping</code></a>, <a href="#GenomePermutations.countoverlapping"><code>GenomePermutations.countoverlapping</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sdangelis/GenomePermutations.jl/blob/f21541e71e327d8d7cca592a9a709520d091044a/src/Overlaps.jl#L1-L23">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GenomePermutations.alloverlapping" href="#GenomePermutations.alloverlapping"><code>GenomePermutations.alloverlapping</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">alloverlapping(a::GenomicFeatures.IntervalCollection{T}, b::GenomicFeatures.IntervalCollection{S})</code></pre><p>Linearly check if all intervals in collection a overlap collection b.  Return true or false</p><pre><code class="language-julia hljs">using GenomicFeatures 
a = GenomicFeatures.IntervalCollection([
	GenomicFeatures.Interval(&quot;chr1&quot;, 14, 17),
	GenomicFeatures.Interval(&quot;chr1&quot;, 20, 25)
	])
b = GenomicFeatures.IntervalCollection([
	GenomicFeatures.Interval(&quot;chr1&quot;, 5, 10),
	GenomicFeatures.Interval(&quot;chr1&quot;, 20, 25)
	])
alloverlapping(a, b) 
	
# output

false</code></pre><p>See Also <a href="#GenomePermutations.anyoverlapping"><code>GenomePermutations.anyoverlapping</code></a>, <a href="#GenomePermutations.countoverlapping"><code>GenomePermutations.countoverlapping</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sdangelis/GenomePermutations.jl/blob/f21541e71e327d8d7cca592a9a709520d091044a/src/Overlaps.jl#L32-L56">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GenomePermutations.countoverlapping" href="#GenomePermutations.countoverlapping"><code>GenomePermutations.countoverlapping</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">countoverlapping(a::GenomicFeatures.IntervalCollection{T} , b::GenomicFeatures.IntervalCollection{T})</code></pre><p>Linearly count how many intervals in collection a overlap with any interval in collection b.</p><pre><code class="language-julia hljs">
using GenomicFeatures 
a = GenomicFeatures.IntervalCollection([
	GenomicFeatures.Interval(&quot;chr1&quot;, 14, 17),
	GenomicFeatures.Interval(&quot;chr1&quot;, 20, 50)
	])
b = GenomicFeatures.IntervalCollection([
	GenomicFeatures.Interval(&quot;chr1&quot;, 5, 10),
	GenomicFeatures.Interval(&quot;chr1&quot;, 25, 35 ),
	GenomicFeatures.Interval(&quot;chr1&quot;, 40, 65)
	])

[countoverlapping(a, b), countoverlapping(b, a)]

# output

2-element Vector{Int64}:
 1
 2</code></pre><p>#Note  As seen above, countoverlapping(a,b) != countoverlapping(b,a) as one interval in a  can overlap with &gt;1 intervals in b.</p><p>See Also <a href="#GenomePermutations.anyoverlapping"><code>GenomePermutations.anyoverlapping</code></a>, <a href="#GenomePermutations.alloverlapping"><code>GenomePermutations.alloverlapping</code></a>,  <a href="#GenomePermutations.countoverlaps"><code>GenomePermutations.countoverlaps</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sdangelis/GenomePermutations.jl/blob/f21541e71e327d8d7cca592a9a709520d091044a/src/Overlaps.jl#L65-L98">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GenomePermutations.countoverlaps" href="#GenomePermutations.countoverlaps"><code>GenomePermutations.countoverlaps</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">countoverlaps(a::GenomicFeatures.IntervalCollection{T},b::GenomicFeatures.IntervalCollection{S})</code></pre><p>linearly counts how many intervals in collection b overlaps with collection a  </p><pre><code class="language-julia hljs">
using GenomicFeatures 
a = GenomicFeatures.IntervalCollection([
	GenomicFeatures.Interval(&quot;chr1&quot;, 14, 17),
	GenomicFeatures.Interval(&quot;chr1&quot;, 20, 50)
	])
b = GenomicFeatures.IntervalCollection([
	GenomicFeatures.Interval(&quot;chr1&quot;, 5, 10),
	GenomicFeatures.Interval(&quot;chr1&quot;, 25, 35 ),
	GenomicFeatures.Interval(&quot;chr1&quot;, 40, 65)
	])

[countoverlaps(a, b), countoverlaps(b, a)]

# output

2-element Vector{Int64}:
 2
 2</code></pre><p>#Note  As seen above, countoverlapping(a,b) == countoverlapping(b,a) as we count the total number  of overlaps for each interval</p><p>See Also <a href="#GenomePermutations.anyoverlapping"><code>GenomePermutations.anyoverlapping</code></a>, <a href="#GenomePermutations.alloverlapping"><code>GenomePermutations.alloverlapping</code></a>,  <a href="#GenomePermutations.countoverlaps"><code>GenomePermutations.countoverlaps</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sdangelis/GenomePermutations.jl/blob/f21541e71e327d8d7cca592a9a709520d091044a/src/Overlaps.jl#L112-L145">source</a></section></article><h2 id="Distance-calculations"><a class="docs-heading-anchor" href="#Distance-calculations">Distance calculations</a><a id="Distance-calculations-1"></a><a class="docs-heading-anchor-permalink" href="#Distance-calculations" title="Permalink"></a></h2><p>GenomePermutations contains functions to calculate distances between intervals and/or collections.</p><article class="docstring"><header><a class="docstring-binding" id="GenomePermutations.dist" href="#GenomePermutations.dist"><code>GenomePermutations.dist</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">dist(a, b)</code></pre><p>Return the unsigend distance between the two breakpoints of Intervals a and b or  missing if the two intervals do not have the same seqname. </p><pre><code class="language-julia hljs">
using GenomicFeatures 
a = GenomicFeatures.Interval(&quot;chr1&quot;, 10, 20)
b = GenomicFeatures.Interval(&quot;chr1&quot;, 30, 65)
    
[dist(a, b), dist(b, a)]

# output

2-element Vector{Int64}:
 10
 10</code></pre><p>See Also <a href="#GenomePermutations.featuredist"><code>GenomePermutations.featuredist</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sdangelis/GenomePermutations.jl/blob/f21541e71e327d8d7cca592a9a709520d091044a/src/Dist.jl#L1-L23">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GenomePermutations.featuredist" href="#GenomePermutations.featuredist"><code>GenomePermutations.featuredist</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">featuredist(interval feature)</code></pre><p>returns the feature distance between the breakpoints of an interval </p><p>Unilke normal distance, the feature distance takes into account overlaps between intervals and figures,  returning 0 if an interval breakpoint </p><p>See Also <a href="#GenomePermutations.dist"><code>GenomePermutations.dist</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sdangelis/GenomePermutations.jl/blob/f21541e71e327d8d7cca592a9a709520d091044a/src/Dist.jl#L30-L39">source</a></section></article><blockquote><p>**NOTE:* Distance functions uses the maximum integer representable in memory to intialise the distance for performance reasons. However, in the unlikely event the real distance is equal to this value the function will return <code>missing</code>.</p></blockquote><h2 id="Genome-Distributions"><a class="docs-heading-anchor" href="#Genome-Distributions">Genome Distributions</a><a id="Genome-Distributions-1"></a><a class="docs-heading-anchor-permalink" href="#Genome-Distributions" title="Permalink"></a></h2><p>All Genome Distributions have shared methods.</p><p>All implement two methods, one to draw a random interval, and another to randomize a given interval.</p><p>The main difference is while <code>randomise</code> will use the length of the provided interval (and if by_chromosome = true, the chromosome) to, rand will always draw them at random from the lengths and chromosome distribution.   Moreover, while <code>rand</code> will always return empty metadata with nothing type for metadata, <code>randomise</code> should conserve type and content of the metadata from the original  - although this depends on the exact implementation of the specific genome distribution type</p><p>The following methods that extend rand, and <code>randomise</code> along a whole collection are shared by all Genome Distributions, unless otherwise specified.</p><article class="docstring"><header><a class="docstring-binding" id="Base.rand-Tuple{AbstractGenomeDist, Int64}" href="#Base.rand-Tuple{AbstractGenomeDist, Int64}"><code>Base.rand</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Base.rand(distribution::AbstractGenomeDist, n::Int)</code></pre><p>Wraps the rand(&lt;:AbstractGenomeDit) function to return a collection with nothing as metadata of n random intervals</p><p>Returns an interval collection with n intervals drawn from the distribution.</p><p><strong>Note</strong></p><p>if n = 1, a collection of size 1 is returned, if n = 0 a </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sdangelis/GenomePermutations.jl/blob/f21541e71e327d8d7cca592a9a709520d091044a/src/Rand.jl#L36-L45">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GenomePermutations.randomise-Tuple{IntervalCollection, AbstractGenomeDist}" href="#GenomePermutations.randomise-Tuple{IntervalCollection, AbstractGenomeDist}"><code>GenomePermutations.randomise</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">randomise(collection::IntervalCollection, distribution::AbstractGenomeDist)</code></pre><p>Waps randomise(&lt;:AbstractGenomeDist) to randomise a given IntervalCollection</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sdangelis/GenomePermutations.jl/blob/f21541e71e327d8d7cca592a9a709520d091044a/src/Rand.jl#L79-L83">source</a></section></article><h3 id="Start-Mixture"><a class="docs-heading-anchor" href="#Start-Mixture">Start Mixture</a><a id="Start-Mixture-1"></a><a class="docs-heading-anchor-permalink" href="#Start-Mixture" title="Permalink"></a></h3><p>The core idea behind the Start Mixture genome distribution is that  we can create a distribution of the all possible locations an interval can start and then check  at sampling time if an interval of given length l can start at that location and still be contained in the allowed regions. If so, and optionally after checking it is not overlapping the nascient new interval list if the the interval is valid</p><article class="docstring"><header><a class="docstring-binding" id="GenomePermutations.StartMixture" href="#GenomePermutations.StartMixture"><code>GenomePermutations.StartMixture</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">StartMixture(genome, regions, overlaps = false)</code></pre><p>generates a StartsMixture</p><p>Under the hood it creates a ? </p><p>#arguments</p><p>#Avaibale fields     - genome::String </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sdangelis/GenomePermutations.jl/blob/f21541e71e327d8d7cca592a9a709520d091044a/src/Rand.jl#L93-L104">source</a></section></article><h3 id="Work-in-progress"><a class="docs-heading-anchor" href="#Work-in-progress">Work in progress</a><a id="Work-in-progress-1"></a><a class="docs-heading-anchor-permalink" href="#Work-in-progress" title="Permalink"></a></h3><p>Currently, there are some Genome Distributions - including some lifted straight out of RegioneR - that are sketched out but not yet implemented.</p><article class="docstring"><header><a class="docstring-binding" id="GenomePermutations.CircularRandomiser" href="#GenomePermutations.CircularRandomiser"><code>GenomePermutations.CircularRandomiser</code></a> — <span class="docstring-category">Type</span></header><section><div><p>To Do The idea here is to rotate all segments by a x amount as if the chromosome was circular.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sdangelis/GenomePermutations.jl/blob/f21541e71e327d8d7cca592a9a709520d091044a/src/Rand.jl#L211-L214">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GenomePermutations.RegionRandomiser" href="#GenomePermutations.RegionRandomiser"><code>GenomePermutations.RegionRandomiser</code></a> — <span class="docstring-category">Type</span></header><section><div><p>To Do</p><p>the idea here is to IDK what the idea is.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sdangelis/GenomePermutations.jl/blob/f21541e71e327d8d7cca592a9a709520d091044a/src/Rand.jl#L220-L224">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GenomePermutations.AdaptiveRegions" href="#GenomePermutations.AdaptiveRegions"><code>GenomePermutations.AdaptiveRegions</code></a> — <span class="docstring-category">Type</span></header><section><div><p>To Do</p><p>the idea here is to regenerate the possible distribution at each iteartion</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sdangelis/GenomePermutations.jl/blob/f21541e71e327d8d7cca592a9a709520d091044a/src/Rand.jl#L230-L234">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GenomePermutations.lengthsMixture" href="#GenomePermutations.lengthsMixture"><code>GenomePermutations.lengthsMixture</code></a> — <span class="docstring-category">Type</span></header><section><div><p>To Do</p><p>the idea here is to create a series of possible start position for each length in a given collection</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sdangelis/GenomePermutations.jl/blob/f21541e71e327d8d7cca592a9a709520d091044a/src/Rand.jl#L240-L244">source</a></section></article><p>if any sounds like the kind, I&#39;m always looking for contributors. See the <a href="#Extending-Genome-Permutations">section</a> on extending Genome Permutations for more info</p><h2 id="Permutation-tests"><a class="docs-heading-anchor" href="#Permutation-tests">Permutation tests</a><a id="Permutation-tests-1"></a><a class="docs-heading-anchor-permalink" href="#Permutation-tests" title="Permalink"></a></h2><p>Before we discuss the permutation test function,  We need to introduce the structure that holds the results</p><article class="docstring"><header><a class="docstring-binding" id="GenomePermutations.PermTestResult" href="#GenomePermutations.PermTestResult"><code>GenomePermutations.PermTestResult</code></a> — <span class="docstring-category">Type</span></header><section><div><p>PermTestResult{S &lt;: Union{Real, Vector{&lt;:Real}}, N &lt;: Union{Real, Vector{&lt;:Real}}, T &lt;: Any}</p><p>A structure to store results of any permutation test implements pvalue.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sdangelis/GenomePermutations.jl/blob/f21541e71e327d8d7cca592a9a709520d091044a/src/Stats.jl#L47-L52">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HypothesisTests.pvalue-Tuple{PermTestResult}" href="#HypothesisTests.pvalue-Tuple{PermTestResult}"><code>HypothesisTests.pvalue</code></a> — <span class="docstring-category">Method</span></header><section><div><p>HypothesisTests.pvalue(test::GenomePermutations.PermTestResult)</p><p>Extends HypothesisTests.pvalue to get the P value of a GenomePermutations.PermTestResult.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sdangelis/GenomePermutations.jl/blob/f21541e71e327d8d7cca592a9a709520d091044a/src/Stats.jl#L66-L70">source</a></section></article><p>In the spirit of RegioneR, we can derive a quick P-value by simply</p><article class="docstring"><header><a class="docstring-binding" id="GenomePermutations.simpleP" href="#GenomePermutations.simpleP"><code>GenomePermutations.simpleP</code></a> — <span class="docstring-category">Function</span></header><section><div><p>simpleP(obs, ran, iterations; alternative :Auto)</p><p>Calculates the p value for the alternative hypothesis that the observed value is either more or less than what we expect from the Vecor of random values.</p><p>If no altrantive is provided, will be automatically selected  on the basis of the data.</p><p>See also: <a href="https://doi.org/doi:10.18129/B9.bioc.regioneR">regioneR</a>, <a href="#GenomePermutations.SimplePTest"><code>SimplePTest</code></a> Please see regioneR for full details</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sdangelis/GenomePermutations.jl/blob/f21541e71e327d8d7cca592a9a709520d091044a/src/Stats.jl#L1-L12">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HypothesisTests.pvalue-Tuple{SimplePTest}" href="#HypothesisTests.pvalue-Tuple{SimplePTest}"><code>HypothesisTests.pvalue</code></a> — <span class="docstring-category">Method</span></header><section><div><p>HypothesisTests.pvalue(test::GenomePermutations.SimplePTest)</p><p>Extends HypothesisTests.pvalue to get the P value of a GenomePermutations.SimplePTest.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sdangelis/GenomePermutations.jl/blob/f21541e71e327d8d7cca592a9a709520d091044a/src/Stats.jl#L76-L80">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GenomePermutations.SimplePTest" href="#GenomePermutations.SimplePTest"><code>GenomePermutations.SimplePTest</code></a> — <span class="docstring-category">Type</span></header><section><div><p>SimplePTest(iterations::Int, p_val::, alternative::)</p><p>A structure to save RegioneR - style simple P tests. Implements <code>pvalue</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sdangelis/GenomePermutations.jl/blob/f21541e71e327d8d7cca592a9a709520d091044a/src/Stats.jl#L30-L34">source</a></section></article><p>We can then run a permutation test with <code>permtest</code></p><article class="docstring"><header><a class="docstring-binding" id="GenomePermutations.permtest-Tuple{IntervalCollection, IntervalCollection, AbstractGenomeDist, Int64}" href="#GenomePermutations.permtest-Tuple{IntervalCollection, IntervalCollection, AbstractGenomeDist, Int64}"><code>GenomePermutations.permtest</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">permtest(randomised_collection, tested_collection, distribution, iterations, f; bed_names)</code></pre><p>Runs a flexible permuation test, using a custsom evaluation function <code>f</code>.</p><p><strong>Arguments</strong></p><ul><li><code>col1::GenomicFeatures.IntervalCollection{}</code>: the collection to randomise.</li><li><code>col2::GenomicFeatures.IntervalCollection{}</code>: the constant collection to test.</li><li><code>distribution::GenomicFeatures.AbstractGenomeDist</code>: the genbome dist to use for the randomisation</li><li><code>iterations::Int</code>: the number of iterations to run.</li><li><code>f::Function = GenomePermutations.dist</code>: the evaluation function. </li></ul><p>Defaults to GenomePermutations.dist.</p><ul><li><code>bed_names::Tuple{Union{String, Nothing}}</code>: the names of the bed files to write to.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sdangelis/GenomePermutations.jl/blob/f21541e71e327d8d7cca592a9a709520d091044a/src/GenomePermutations.jl#L534-L548">source</a></section></article><h2 id="Extending-Genome-Permutations"><a class="docs-heading-anchor" href="#Extending-Genome-Permutations">Extending Genome Permutations</a><a id="Extending-Genome-Permutations-1"></a><a class="docs-heading-anchor-permalink" href="#Extending-Genome-Permutations" title="Permalink"></a></h2><p>While sensible distance functions and genomeDistributions are provided, It should be possible to add new custom <code>GenomDist</code> types.</p><p>These custom types must be a subtype of the abstract <code>AbstractGenomeDist</code> type and must conform to the specification below</p><article class="docstring"><header><a class="docstring-binding" id="GenomePermutations.AbstractGenomeDist" href="#GenomePermutations.AbstractGenomeDist"><code>GenomePermutations.AbstractGenomeDist</code></a> — <span class="docstring-category">Type</span></header><section><div><p>md AbstractGenomeDist is a base type for all AbstractGenomeDist objects.</p><p>All AbstractGenomeDist objects should have:  </p><p>AT LEAST the following properties:  </p><pre><code class="nohighlight hljs">- genome::String the name of the genome  
- _regions::IntervalCollection the regions the genome distribution is  
- _distribution::Distribution the distribution to draw samples from  
- overlaps::Bool whether the sampled regions can overlap  
- _seqs the sequences of the regions used for the randomisation  
- _chr_distribution::Distribution the distribution to draw chromosomes from  
- _length_distribution::Distribution the distribution to draw lengths from  
- on_fail::Symbol. The action to take if the randomisation fails to draw a valid interval
shared methods recognise throw (throws an erorr), :continue (skips the interval) or :orig (returns the original interval)</code></pre><p>note properties starting with _ are PRIVATE as they are derived from the regions used,  please DO NOT ALLOW USERS TO SET THEM DIRECTLY.   if you want to allow users to edit any of them you need to allow them to genereate  all of them in one go with something like setfield!(self, :regions, value).   </p><p>You must Implement the follwing methods:  </p><pre><code class="nohighlight hljs">- an appropriate constructor. should enforce on_fail to be one of the standard options, unless specialised methods to handle them are implemented  
- rand(): a method that returns a random interval from the distribution  
- randomise(): a method that returns a random interval from the distribution on the same chromosome
and with the same length of the provided interval</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sdangelis/GenomePermutations.jl/blob/f21541e71e327d8d7cca592a9a709520d091044a/src/Rand.jl#L1-L31">source</a></section></article><p>For reference, the following shared methods are available for all concrete subtypes of <code>AbstractGenomeDistance</code>:</p><pre><code class="language-Julia hljs">Base.rand(::AbstractGenomeDist, ::Int)
randomise(::GenomicFeatures.IntervalCollection, ::AbstractGenomeDist)
Base.show(::AbstractGenomeDist)</code></pre><p>It should also be possible to create a new distance function, as long as it returns 1 value (an <code>Int</code>, or <code>missing</code>) per interval we can rely on looping helpers to create appropriate versions that can handle collections, as needed</p><article class="docstring"><header><a class="docstring-binding" id="GenomePermutations._loopdist" href="#GenomePermutations._loopdist"><code>GenomePermutations._loopdist</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">_loopdist(a, b, f)</code></pre><p>_loopdist loops a distance function f that takes 2 intervals over a and b, handling corner cases.</p><p><strong>Aeguments</strong></p><ul><li>a::GenomicFeatures.Interval or GenomicFeatures.IntervalCollection:  </li><li>b::GenomicFeatures.IntervalCollection</li><li>f::Function</li></ul><p><strong>Note:</strong></p><p>this is a private function that enables <code>featuredist</code> and <code>dist</code> to share the same loop and corner case handling core while being flexible enough to plug any function that takes  two <code>GenomicFeatures.Interval</code> objects as arguments and returns an <code>Int</code> or <code>missing</code></p><p>See Also <a href="#GenomePermutations.dist"><code>GenomePermutations.dist</code></a>, <a href="#GenomePermutations.featuredist"><code>GenomePermutations.featuredist</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sdangelis/GenomePermutations.jl/blob/f21541e71e327d8d7cca592a9a709520d091044a/src/Dist.jl#L67-L83">source</a></section><section><div><pre><code class="nohighlight hljs">_loopdist(a, b, f)</code></pre><p>_loopdist loops a distance function f that takes 2 intervals over a and b, handling corner cases.</p><p><strong>Aeguments</strong></p><ul><li>a::GenomicFeatures.Interval or GenomicFeatures.IntervalCollection:  </li><li>b::GenomicFeatures.IntervalCollection</li><li>f::Function</li></ul><p><strong>Note:</strong></p><p>this is a private function that enables <code>featuredist</code> and <code>dist</code> to share the same loop and corner case handling core while being flexible enough to plug any function that takes  two <code>GenomicFeatures.Interval</code> objects as arguments and returns an <code>Int</code> or <code>missing</code></p><p>See Also <a href="#GenomePermutations.dist"><code>GenomePermutations.dist</code></a>, <a href="#GenomePermutations.featuredist"><code>GenomePermutations.featuredist</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sdangelis/GenomePermutations.jl/blob/f21541e71e327d8d7cca592a9a709520d091044a/src/Dist.jl#L83-L99">source</a></section></article><p>You can then alias your distance as needed</p><pre><code class="language-Julia hljs">function mydist(a::Interval, b::IntervalCollection) 
    _loopdist(a, b, mydist)
end 

function  mydist(a::IntervalCollection, b::IntervalCollection)
    _loopdist(a, b, mydist)
end</code></pre><p>in fact simply calling <code>_loopdist</code> from an untyped function should suffice.</p><pre><code class="language-Julia hljs">function mydist(a, b) 
    _loopdist(a, b, mydist)
end</code></pre><p>As long as you conform  to both specifications, your new distance and genome distribution should work with the permutation test.</p><h2 id="Legacy-Functions"><a class="docs-heading-anchor" href="#Legacy-Functions">Legacy Functions</a><a id="Legacy-Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Legacy-Functions" title="Permalink"></a></h2><p>These functions were in use prior to the new Genome Distribution type systems are are deprecate due to their unstable and at times confusing output and clunky function calls.   Will be officially deprecated and/or removed altogether by version 1.0.0</p><p><strong>DEPRECATION WARNING!: PLEASE DO NOT USE THEM</strong></p><article class="docstring"><header><a class="docstring-binding" id="GenomePermutations.generatedistribution" href="#GenomePermutations.generatedistribution"><code>GenomePermutations.generatedistribution</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">generatedistribution(collection)</code></pre><p>Generate a Distributions.MixtureModel from the collection </p><p>The model assumes each position of the genome has equal probability of being sampled. Practically, it is modelled as a mixture model of individual discrete uniform distributions, one for each interval in the collection. The component distributions are distribuited according to a categorical distribution, with  probabilities proportional to the length of each interval.</p><p><strong>Note</strong></p><p>At the moment it only supports collections with single sequence. Generating a distribution from an overlapping collection is undocumented (I assume it would add up the probability but this is untested)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sdangelis/GenomePermutations.jl/blob/f21541e71e327d8d7cca592a9a709520d091044a/src/GenomePermutations.jl#L59-L75">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GenomePermutations.randominterval" href="#GenomePermutations.randominterval"><code>GenomePermutations.randominterval</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">randominterval(interval, distribution, regions, collection; allow_overlap, max_tries, onfail)</code></pre><p>Randomises the position of an interval according to a given distribution. </p><p><strong>Arguments</strong></p><ul><li><code>interval::GenomicFeatures.IntervalCollection</code>: The interval to randomise</li><li><code>distribution::Distributions.Sampleable</code>: distribution of possible interval start location.</li></ul><p>Should be a discrete distribution, although right now this is not enforced at the signature level</p><ul><li><code>regions::</code>: the regions the new interval should be fully contained in (checked by<code>isin</code>)</li><li><code>collecton::GenomicFeatures.IntervalCollection =  GenomicFeatures.IntervalCollection{T}()</code>: Collection to avoid overlapping </li></ul><p>to if allow_overlap is set to false, defaults to an empty collection of metadata .</p><ul><li><code>allow_overlap::Bool = true</code>: whether to allow overlaps to collection.</li><li><code>max_tries::Int = 1000</code>: the maximum number of attempts to draw an interval that fits in</li></ul><p>the region from the distribution</p><ul><li><code>onfail::Symbol = :throw</code>: what to do if the interval fails to fit in the region.</li></ul><p>Will return the orignal interval if :orig, returns nothing if :skip or throw an error if :throw.</p><p><strong>Note</strong></p><p>To prevent intervals in a loop from overlapping each other, use  <code>allow_overlap = false</code> and add the result of each iteration to the collection paseed to the function.</p><p>See Also (_randominterval)[@ref]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sdangelis/GenomePermutations.jl/blob/f21541e71e327d8d7cca592a9a709520d091044a/src/GenomePermutations.jl#L145-L172">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GenomePermutations.randomisegenome" href="#GenomePermutations.randomisegenome"><code>GenomePermutations.randomisegenome</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">randomisegenome(col, regions; allow_overlap, max_tries)</code></pre><p>Randomises a collection, sequence by sequence along the specified regions, returning the new collection</p><p><strong>rguments</strong></p><ul><li><code>col::GenomicFeatrues.IntervalCollection{T}</code>: collection to randomise</li><li><code>regions::GenomicFeatures.IntervalCollection{S}</code>: regions to randomise the collection in.</li><li><code>allow_overlap::Bool = false</code>: whether to allow overlapping intervals in the result.</li><li><code>max_tries::Int = 1000</code>: maximum number of attempts to draw an interval</li></ul><p>that fits in the regions.</p><ul><li><code>onfail::Symbol = :throw</code>: what to do if an interval fails to fit in the regions.</li></ul><p>Will return the orignal interval if :orig, skip the interval if :skip, otherwise throws an error.</p><p>Note: it will skip any sequences in the collection not found in the target regions. If no sequences are found returns an empty collection.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sdangelis/GenomePermutations.jl/blob/f21541e71e327d8d7cca592a9a709520d091044a/src/GenomePermutations.jl#L247-L264">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GenomePermutations.randomiseregions" href="#GenomePermutations.randomiseregions"><code>GenomePermutations.randomiseregions</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">randomiseregions(collection, distribution, regions; allow_overlap, max_tries, onfail)</code></pre><p>Generates randomised regions from an interval collection according to a start postion distribution. It guarantees that the new intervals are contained in the given regions.</p><p><strong>Arguments</strong></p><ul><li><code>collection::GenomicFeatures.IntervalCollection{T}</code>: collection to randomise,</li></ul><p>must have only 1 sequence.</p><ul><li><code>distribution::Distributions.Sampleable</code>: distribution of possible interval</li></ul><p>start locations, must match collection.</p><ul><li><code>regions::GenomicFeatures.IntervalCollection{S}</code>: regions to randomise the intervals in.</li><li>`allow_overlap::Bool = false.</li><li><code>max_tries::Int = 1000</code>: maximum number of attempts to draw an interval</li></ul><p>that fits in the region from the distribution.</p><ul><li><code>onfail::Symbol = :throw</code>: what to do if an interval fails to fit in the region.</li></ul><p>Will return the orignal interval if :orig, skip the interval if :skip, otherwise throws an error.</p><p><strong>Notes</strong></p><p>this functions assumes that the interval collection contains intervals belonging  to a single sequence that is the same sequence used for the distribution.  The distribution should be derived from the regions. If the distribution and the regions don&#39;t match it will most likely fail safely New intervals overlapping with other intervals in the nascient collection are disallowed by default. To allow overlaps use `allow_overlap = true</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sdangelis/GenomePermutations.jl/blob/f21541e71e327d8d7cca592a9a709520d091044a/src/GenomePermutations.jl#L200-L227">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GenomePermutations.overlappermtest" href="#GenomePermutations.overlappermtest"><code>GenomePermutations.overlappermtest</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">overlappermtest(col1, col2, regions, iterations; bed_names, allow_overlap = false,
max_tries = 1000, onfail = :throws)</code></pre><p>Legacy function to run an overlap permutation test across 2 regions. will be replaced by <code>permtest</code> using countoverlapping as <code>f</code> argument. Will need a <code>g</code> function to summarise overlaps across regions. (likely <code>sum</code>).</p><p><strong>Arguments</strong></p><ul><li><code>col1::GenomicFeatures.IntervalCollection{T}</code>: the collection to randomise.</li><li><code>col2::GenomicFeatures.IntervalCollection{S}</code>: the constant collection to test.</li><li><code>regions::GenomicFeatures.IntervalCollection{S}</code>: the regions col1 is randomised in.</li><li><code>iterations::Int</code>: the number of iterations to run.</li><li><code>bed_names::Union{String, Nothing}</code>: the names of the bed files to write to.</li><li><code>allow_overlap::Bool = false</code>: whether to allow overlaps in the randomised regions.</li><li><code>max_tries::Int</code>: the maximum number of tries to generate a randomised collection.</li><li><code>onfail::Symbol = :throw</code>: what to do if a random interval fails to fit in the region.</li></ul><p>Will return the orignal interval if :orig, skip the interval if :skip, otherwise throws an error.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sdangelis/GenomePermutations.jl/blob/f21541e71e327d8d7cca592a9a709520d091044a/src/GenomePermutations.jl#L308-L327">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GenomePermutations.permtest-Tuple{IntervalCollection, IntervalCollection, IntervalCollection, Int64}" href="#GenomePermutations.permtest-Tuple{IntervalCollection, IntervalCollection, IntervalCollection, Int64}"><code>GenomePermutations.permtest</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">permtest(col1, col2, regions, iterations, f; allow_overlap = false, max_tries::Int = 1000, onfail = :throw)</code></pre><p>Runs a flexible permuation test, using a custsom evaluation function <code>f</code>.</p><p><strong>Arguments</strong></p><ul><li><code>col1::GenomicFeatures.IntervalCollection{}</code>: the collection to randomise.</li><li><code>col2::GenomicFeatures.IntervalCollection{}</code>: the constant collection to test.</li><li><code>regions::GenomicFeatures.IntervalCollection{}</code>: the regions col1 is randomised in.</li><li><code>iterations::Int</code>: the number of iterations torun.</li><li><code>f::Function = GenomePermutations.dist</code>: the evaluation function. </li></ul><p>Defaults to GenomePermutations.dist.</p><ul><li><code>bed_names::TupleUnion{String, Nothing}</code>: the names of the bed files to write to.</li><li><code>allow_overlap::Bool = false</code>: whether to allow overlaps in the randomised regions.</li><li><code>max_tries::Int = 1000</code>: the maximum number of tries to generate a randomised collection.</li><li><code>onfail::Symbol = :throw</code>: what to do if a random interval fails to fit in the region.</li></ul><p>Will return the orignal interval if :orig, skips it if :skip, otherwise throws an error.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sdangelis/GenomePermutations.jl/blob/f21541e71e327d8d7cca592a9a709520d091044a/src/GenomePermutations.jl#L438-L456">source</a></section></article><p>These functions are not only deprecated but are also to be considered internal and private</p><article class="docstring"><header><a class="docstring-binding" id="GenomePermutations.iter_getcollection" href="#GenomePermutations.iter_getcollection"><code>GenomePermutations.iter_getcollection</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">iter_getcollection(collection::GenomicFeatures.IntervalCollection{T}, sequence::String)</code></pre><p>(inefficiently) retun a interval collection with only features in the specified sequence. There should be a better way to do this.</p><p>see also <a href="#GenomePermutations.vec_getcollection"><code>GenomePermutations.vec_getcollection</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sdangelis/GenomePermutations.jl/blob/f21541e71e327d8d7cca592a9a709520d091044a/src/GenomePermutations.jl#L40-L47">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GenomePermutations.vec_getcollection" href="#GenomePermutations.vec_getcollection"><code>GenomePermutations.vec_getcollection</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">vec_getcollection(collection::GenomicFeastures.IntervalCollection{T}, sequence::String)</code></pre><p>(inefficiently) retun a interval collection with only features in the specified sequence. There should be a better way to do this.</p><p>See Also <a href="#GenomePermutations.iter_getcollection"><code>GenomePermutations.iter_getcollection</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sdangelis/GenomePermutations.jl/blob/f21541e71e327d8d7cca592a9a709520d091044a/src/GenomePermutations.jl#L25-L33">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GenomePermutations._randomgenome" href="#GenomePermutations._randomgenome"><code>GenomePermutations._randomgenome</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">_randomgenome(regions, n, C, L, names; allow_overlap = false)</code></pre><p>Generates a new random genome with n segments from a named sequence distribution</p><p><strong>Arguments</strong></p><ul><li><code>regions</code>: the regions the genome to generate belongs to.</li><li><code>n::Int</code>: the number of segments to generate.</li><li><code>C::Distributions.Categorical</code>: a distibution with each cateogy representing</li></ul><p>one of the named sequences. Lenght and order must match names.</p><ul><li>`L::Distributions.DiscreteUniform&quot;: the segment lenght distribution.</li><li><code>names::Vector{Strimg}</code>: the names of the sequences. must match the categories in C.</li><li><code>allow_overlap::Bool = false</code>: whether to allow overlapping segments in the result.</li></ul><p>This is currently private as I have not tested this and I don&#39;t like the categorical distribution squence names situation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sdangelis/GenomePermutations.jl/blob/f21541e71e327d8d7cca592a9a709520d091044a/src/GenomePermutations.jl#L393-L411">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GenomePermutations._randominterval" href="#GenomePermutations._randominterval"><code>GenomePermutations._randominterval</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">_randominterval(interval::GenomicFeatures.Interval{T}, 
	distribution::Distributions.Sampleable, regions::GenomicFeatures.IntervalCollection{S};
	collection::GenomicFeatures.IntervalCollection{T} = GenomicFeatures.IntervalCollection{T}(), 
	allow_overlap::Bool = true, max_tries::Int = 1000) where {T, S}}</code></pre><p>This is the private version of randominterval, it skips sequence assertions in the name of performance Does it actually improve performance? Debeatable, in theory it prevents 100s of IFs. In practice, I haven&#39;t tested it. Indeed, branch prediction on asymmetrical branches should mean  that the ifs are not really that damaging to performance.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sdangelis/GenomePermutations.jl/blob/f21541e71e327d8d7cca592a9a709520d091044a/src/GenomePermutations.jl#L89-L99">source</a></section></article></article><nav class="docs-footer"><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.13 on <span class="colophon-date" title="Tuesday 13 September 2022 16:04">Tuesday 13 September 2022</span>. Using Julia version 1.8.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
