var documenterSearchIndex = {"docs":
[{"location":"","page":"Home","title":"Home","text":"CurrentModule = GenomePermutations","category":"page"},{"location":"#GenomePermutations","page":"Home","title":"GenomePermutations","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for GenomePermutations.","category":"page"},{"location":"","page":"Home","title":"Home","text":"GenomePermutations is an opinionated Julia reimplementation of  R's RegioneR. Built on top of GenomicFeatures.jl it allows to genome permutation tests at scale","category":"page"},{"location":"","page":"Home","title":"Home","text":"It additionally defines utility functions to calculate interval distances and overlaps, as well as ","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"Modules = [GenomePermutations]","category":"page"},{"location":"#GenomePermutations.AbstractGenomeDist","page":"Home","title":"GenomePermutations.AbstractGenomeDist","text":"AbstractGenomeDist is a base type for all AbstractGenomeDist objects.\n\nAll AbstractGenomeDist objects should have:\n\nAT LEAST the following properties:     - genome::String the name of the genome     - regions::IntervalCollection the regions the genome distribution is      - _distribution::Distribution the distribution to draw samples from     - overlaps::Bool whether the sampled regions can overlap     - _seqs the sequences of the regions used for the randomisation.     - _chrdistribution::Distribution the distribution to draw chromosomes from     - lengthdistribution::Distribution the distribution to draw lengths from     - on_fail::Symbol. The action to take if the randomisation fails to draw a valid interval.      shared methods recognise throw (throws an erorr), :continue (skips the interval) or :orig (returns the original interval)\n\nnote properties starting with _ are PRIVATE as they are derived from the regions used, pelase DO NOT SET THEM DIRECTLY. To edit any of them you need to alter the regions with setfield!(self, :regions, value). \n\nImplement the follwing methods:     - an appropriate constructor. should enforce on_fail to be one of the standard options, unless specialised methods to handle them are implemented.     - setfields!(self, :regions, value) to change the regions     - rand(): a method that returns a random interval from the distribution     - randomise(): a method that returns a rnadom interval from the distribution on the same chromosome     and with the same length of the provided interval.\n\nAbstractGenomeDist has shared methods that can be used by all AbstractGenomeDist objects.     - randomise(::AbstractGenomeDist, ): a method that wraps randomise() to randomise a given intervalcollection      - rand(::AbstractGenomeDist, n::Int): a Wraps rand() to return a collection of n random intervals     - pretty printing functions     - getters and setteres  please override amy abstract-level methods for custome genome rand objects as required\n\n\n\n\n\n","category":"type"},{"location":"#GenomePermutations.AdaptiveRegions","page":"Home","title":"GenomePermutations.AdaptiveRegions","text":"To Do\n\nthe idea here is to regenerate the possible distribution at each iteartion\n\n\n\n\n\n","category":"type"},{"location":"#GenomePermutations.CircularRandomiser","page":"Home","title":"GenomePermutations.CircularRandomiser","text":"To Do The idea here is to rotate all segments by a x amount as if the chromosome was circular.\n\n\n\n\n\n","category":"type"},{"location":"#GenomePermutations.PermTestResult","page":"Home","title":"GenomePermutations.PermTestResult","text":"PermTestResult{S <: Union{Real, Vector{<:Real}}, N <: Union{Real, Vector{<:Real}}, T <: Any}\n\nA structure to store results of any permutation test implements pvalue.\n\n\n\n\n\n","category":"type"},{"location":"#GenomePermutations.RegionRandomiser","page":"Home","title":"GenomePermutations.RegionRandomiser","text":"To Do\n\nthe idea here is to IDK what the idea is.\n\n\n\n\n\n","category":"type"},{"location":"#GenomePermutations.SimplePTest","page":"Home","title":"GenomePermutations.SimplePTest","text":"SimplePTest(iterations::Int, p_val::, alternative::)\n\nA structure to save RegioneR - style simple P tests. Implements pvalue\n\n\n\n\n\n","category":"type"},{"location":"#GenomePermutations.StartMixture","page":"Home","title":"GenomePermutations.StartMixture","text":"StartMixture(genome, regions, overlaps = false)\n\ngenerates a genome rand object.\n\n\n\n\n\n","category":"type"},{"location":"#GenomePermutations.lengthsMixture","page":"Home","title":"GenomePermutations.lengthsMixture","text":"To Do\n\nthe idea here is to create a series of possible start position for each length in a given collection\n\n\n\n\n\n","category":"type"},{"location":"#GenomePermutations._randomgenome-Tuple{Any, Int64, Distributions.Categorical{P, Ps} where {P<:Real, Ps<:AbstractVector{P}}, Distributions.DiscreteDistribution, Vector{String}}","page":"Home","title":"GenomePermutations._randomgenome","text":"_randomgenome(regions, n, C, L, names; allow_overlap = false)\n\nGenerates a new random genome with n segments from a named sequence distribution\n\nArguments\n\nregions: the regions the genome to generate belongs to.\nn::Int: the number of segments to generate.\nC::Distributions.Categorical: a distibution with each cateogy representing\n\none of the named sequences. Lenght and order must match names.\n\n`L::Distributions.DiscreteUniform\": the segment lenght distribution.\nnames::Vector{Strimg}: the names of the sequences. must match the categories in C.\nallow_overlap::Bool = false: whether to allow overlapping segments in the result.\n\nThis is currently private as I have not tested this and I don't like the categorical distribution squence names situation.\n\n\n\n\n\n","category":"method"},{"location":"#GenomePermutations._randominterval-Union{Tuple{S}, Tuple{T}, Tuple{Interval{T}, Distributions.Sampleable, IntervalCollection{S}}} where {T, S}","page":"Home","title":"GenomePermutations._randominterval","text":"_randominterval(interval::GenomicFeatures.Interval{T}, \n\tdistribution::Distributions.Sampleable, regions::GenomicFeatures.IntervalCollection{S};\n\tcollection::GenomicFeatures.IntervalCollection{T} = GenomicFeatures.IntervalCollection{T}(), \n\tallow_overlap::Bool = true, max_tries::Int = 1000) where {T, S}}\n\nThis is the private version of randominterval, it skips sequence assertions in the name of performance Does it actually improve performance? Debeatable, in theory it prevents 100s of IFs. In practice, I haven't tested it. Indeed, branch prediction on asymmetrical branches should mean  that the ifs are not really that damaging to performance.\n\n\n\n\n\n","category":"method"},{"location":"#GenomePermutations.alloverlapping-Union{Tuple{S}, Tuple{T}, Tuple{IntervalCollection{T}, IntervalCollection{S}}} where {T, S}","page":"Home","title":"GenomePermutations.alloverlapping","text":"alloverlapping(a::GenomicFeatures.IntervalCollection{T}, b::GenomicFeatures.IntervalCollection{S})\n\nLinearly check if all intervals in collection a overlap collection b.  Return true or false\n\nusing GenomicFeatures \na = GenomicFeatures.IntervalCollection([\n\tGenomicFeatures.Interval(\"chr1\", 14, 17),\n\tGenomicFeatures.Interval(\"chr1\", 20, 25)\n\t])\nb = GenomicFeatures.IntervalCollection([\n\tGenomicFeatures.Interval(\"chr1\", 5, 10),\n\tGenomicFeatures.Interval(\"chr1\", 20, 25)\n\t])\nalloverlapping(a, b) \n\t\n# output\n\nfalse\n\nSee Also GenomePermutations.anyoverlapping, GenomePermutations.countoverlapping.\n\n\n\n\n\n","category":"method"},{"location":"#GenomePermutations.anyin-Union{Tuple{S}, Tuple{T}, Tuple{IntervalCollection{T}, IntervalCollection{S}}} where {T, S}","page":"Home","title":"GenomePermutations.anyin","text":"anyin(a:::GenomicFeatures.IntervalCollection{T}, b:::GenomicFeatures.IntervalCollection{S})\n\nLinearly check if any interval in collection a are contained in collection b. \n\n\nusing GenomicFeatures \na = GenomicFeatures.IntervalCollection([\n\tGenomicFeatures.Interval(\"chr1\", 25, 27),\n\tGenomicFeatures.Interval(\"chr1\", 100, 150)\n\t])\nb = GenomicFeatures.IntervalCollection([\n\tGenomicFeatures.Interval(\"chr1\", 5, 10),\n\tGenomicFeatures.Interval(\"chr1\", 25, 35 ),\n\tGenomicFeatures.Interval(\"chr1\", 40, 65)\n\t])\n\t\nanyin(a, b)\n\t\n# output\n\ntrue\n\nNote\n\nAt this point there are 2 layers of linear search so the time complexity is n^2\n\nSee Also GenomePermutations.isin, GenomePermutations.anyin.\n\n\n\n\n\n","category":"method"},{"location":"#GenomePermutations.anyoverlapping-Union{Tuple{S}, Tuple{T}, Tuple{Interval{T}, IntervalCollection{S}}} where {T, S}","page":"Home","title":"GenomePermutations.anyoverlapping","text":"anyoverlapping(a::GenomicFeatures.Interval{T},\nb::GenomicFeatures.IntervalCollection{S})\n\nExtend GenomicFeatures.isoverlapping to linearly check if interval a. overlaps collection. Return true or false\n\nusing GenomicFeatures \na = GenomicFeatures.Interval(\"chr1\", 0, 10)\nb = GenomicFeatures.IntervalCollection([\n\tGenomicFeatures.Interval(\"chr1\", 5, 15),\n\tGenomicFeatures.Interval(\"chr1\", 20, 25)\n\t])\nanyoverlapping(a, b) \n\n# output\n\ntrue\n\nSee Also GenomePermutations.alloverlapping, GenomePermutations.countoverlapping.\n\n\n\n\n\n","category":"method"},{"location":"#GenomePermutations.countoverlapping-Union{Tuple{S}, Tuple{T}, Tuple{IntervalCollection{T}, IntervalCollection{S}}} where {T, S}","page":"Home","title":"GenomePermutations.countoverlapping","text":"countoverlapping(a::GenomicFeatures.IntervalCollection{T} , b::GenomicFeatures.IntervalCollection{T})\n\nLinearly count how many intervals in collection a overlap with any interval in collection b.\n\n\nusing GenomicFeatures \na = GenomicFeatures.IntervalCollection([\n\tGenomicFeatures.Interval(\"chr1\", 14, 17),\n\tGenomicFeatures.Interval(\"chr1\", 20, 50)\n\t])\nb = GenomicFeatures.IntervalCollection([\n\tGenomicFeatures.Interval(\"chr1\", 5, 10),\n\tGenomicFeatures.Interval(\"chr1\", 25, 35 ),\n\tGenomicFeatures.Interval(\"chr1\", 40, 65)\n\t])\n\n[countoverlapping(a, b), countoverlapping(b, a)]\n\n# output\n\n2-element Vector{Int64}:\n 1\n 2\n\n#Note  As seen above, countoverlapping(a,b) != countoverlapping(b,a) as one interval in a  can overlap with >1 intervals in b.\n\nSee Also GenomePermutations.anyoverlapping, GenomePermutations.alloverlapping,  GenomePermutations.countoverlaps.\n\n\n\n\n\n","category":"method"},{"location":"#GenomePermutations.countoverlaps-Union{Tuple{S}, Tuple{T}, Tuple{IntervalCollection{T}, IntervalCollection{S}}} where {T, S}","page":"Home","title":"GenomePermutations.countoverlaps","text":"countoverlaps(a::GenomicFeatures.IntervalCollection{T},b::GenomicFeatures.IntervalCollection{S})\n\nlinearly counts how many intervals in collection b overlaps with collection a  \n\n\nusing GenomicFeatures \na = GenomicFeatures.IntervalCollection([\n\tGenomicFeatures.Interval(\"chr1\", 14, 17),\n\tGenomicFeatures.Interval(\"chr1\", 20, 50)\n\t])\nb = GenomicFeatures.IntervalCollection([\n\tGenomicFeatures.Interval(\"chr1\", 5, 10),\n\tGenomicFeatures.Interval(\"chr1\", 25, 35 ),\n\tGenomicFeatures.Interval(\"chr1\", 40, 65)\n\t])\n\n[countoverlapping(a, b), countoverlapping(b, a)]\n\n# output\n\n2-element Vector{Int64}:\n 2\n 2\n\n#Note  As seen above, countoverlapping(a,b) == countoverlapping(b,a) as we count the total number  of overlaps for each interval\n\nSee Also GenomePermutations.anyoverlapping, GenomePermutations.alloverlapping,  GenomePermutations.countoverlaps\n\n\n\n\n\n","category":"method"},{"location":"#GenomePermutations.dist-Union{Tuple{S}, Tuple{T}, Tuple{Interval{T}, IntervalCollection{S}}, Tuple{Interval{T}, IntervalCollection{S}, Function}} where {T, S}","page":"Home","title":"GenomePermutations.dist","text":"dist(a,b, f = minimum)\n\nLinearly calculate all the distances between an interval a and a collection b, returning a value summarised according to function f.\n\nArguments\n\na::GenomicFeatures.interval{T}: interval to calculate distances from.\nb::GenomicFeatures.IntervalCollection{S}: collection to calculate all distances to.\nf::Function: f Summarise all the pairwise distance for a and each interval in b \n\naccording to the supplied function f  Currently tested with minimum, maximum, mean, and median.\n\nusing GenomicFeatures\nusing Statistics\n\na = GenomicFeatures.Interval(\"chr1\", 25, 35)\n\nb = GenomicFeatures.IntervalCollection([\n\tGenomicFeatures.Interval(\"chr1\", 5, 10),\n\tGenomicFeatures.Interval(\"chr1\", 25, 35 ),\n\tGenomicFeatures.Interval(\"chr1\", 40, 100)\n\t])\n\n[dist(a,b, minimum), dist(a,b, maximum), dist(a,b, mean), dist(a,b, median)]\n# output\n\n4-element Vector{Float64}:\n  0.0\n 15.0\n  6.666666666666667\n  5.0\n\n\n\n\n\n","category":"method"},{"location":"#GenomePermutations.dist-Union{Tuple{T}, Tuple{S}, Tuple{IntervalCollection{T}, IntervalCollection{S}}, Tuple{IntervalCollection{T}, IntervalCollection{S}, Function}, Tuple{IntervalCollection{T}, IntervalCollection{S}, Function, Function}} where {S, T}","page":"Home","title":"GenomePermutations.dist","text":"dist(a, b, f, g)\n\nLineraly caluclates the distance between collection a and b. Each distance between a and b is summarised according to f and then summarised  according to g.\n\nAgruments\n\na::GenomicFeatures.IntervalCollection{T}: collection a.\nb::GenomicFeatures.IntervalCollection{S}: collectionb b.\nf::Function = x -> x: f summarisees the result of the distances \n\nbetween each interval of a and all intervals in b. tested with x -> x, minimum, 'maximum,mean,median`\n\ng::Function = minimum: g summarises the distances returned by f for all\n\nitems in a. Currently tested with minimum. maximum, mean, and median.\n\nNote\n\nBoth g and f can be replaced by user-defined functions. f must take a   Vector{Union{Int, Float64}} and return Union{Int, Float64}. g must take a Vector{Union{Int, Float64}} but can return any type. Due to the fact that the result of f is stored in d before being summarised, it  is not possible to change f's return type  - even if we use a function in g that could acept a vector of that type. Indeed this is the reason for the need to Union{Int, Float64} as the return type of f. but types & their optimisation in Julia can be funny. \n\nusing GenomicFeatures\nusing Statistics\n\na = GenomicFeatures.IntervalCollection([\n\tGenomicFeatures.Interval(\"chr1\", 15, 20),\n\tGenomicFeatures.Interval(\"chr1\", 150, 200)\n\t])\nb = GenomicFeatures.IntervalCollection([\n\tGenomicFeatures.Interval(\"chr1\", 5, 10),\n\tGenomicFeatures.Interval(\"chr1\", 25, 35 ),\n\tGenomicFeatures.Interval(\"chr1\", 40, 100)\n\t])\n\n[dist(a,b, x->x, minimum), dist(a,b, x->x, maximum), dist(a, x->x, mean), dist(a,b, x->x,median)]\n\n# output\n\n4-element Vector{Float64}:\n  5.0\n 50.0\n 27.5\n 27.5\n\n\n\n\n\n","category":"method"},{"location":"#GenomePermutations.dist-Union{Tuple{T}, Tuple{S}, Tuple{Interval{S}, Interval{T}}} where {S, T}","page":"Home","title":"GenomePermutations.dist","text":"dist(a, b)\n\nReturn the minimum unsigend distance between Intervals a and b. returns missing if the two intervals do not have the same seqname. \n\n\nusing GenomicFeatures \na = GenomicFeatures.Interval(\"chr1\", 10, 20)\nb = GenomicFeatures.Interval(\"chr1\", 30, 65)\n    \n[dist(a, b), dist(b, a)]\n\n# output\n\n2-element Vector{Int64}:\n 10\n 10\n\n\n\n\n\n","category":"method"},{"location":"#GenomePermutations.generatedistribution-Tuple{Any}","page":"Home","title":"GenomePermutations.generatedistribution","text":"generatedistribution(collection)\n\nGenerate a Distributions.MixtureModel from the collection \n\nThe model assumes each position of the genome has equal probability of being sampled. Practically, it is modelled as a mixture model of individual discrete uniform distributions, one for each interval in the collection. The component distributions are distribuited according to a categorical distribution, with  probabilities proportional to the length of each interval.\n\nNote\n\nAt the moment it only supports collections with single sequence. Generating a distribution from an overlapping collection is undocumented (I assume it would add up the probability but this is untested)\n\n\n\n\n\n","category":"method"},{"location":"#GenomePermutations.isin-Union{Tuple{S}, Tuple{T}, Tuple{IntervalCollection{T}, IntervalCollection{S}}} where {T, S}","page":"Home","title":"GenomePermutations.isin","text":"isin(a:::GenomicFeatures.IntervalCollection{T}, b:::GenomicFeatures.IntervalCollection{S})\n\nLinearly check if all intervals in collection a are contained in collection b. \n\n```jldoctest\n\nusing GenomicFeatures \na = GenomicFeatures.IntervalCollection([\n\tGenomicFeatures.Interval(\"chr1\", 6, 9),\n\tGenomicFeatures.Interval(\"chr1\", 45, 50)\n\t])\nb = GenomicFeatures.IntervalCollection([\n\tGenomicFeatures.Interval(\"chr1\", 5, 10),\n\tGenomicFeatures.Interval(\"chr1\", 25, 35 ),\n\tGenomicFeatures.Interval(\"chr1\", 40, 65)\n\t])\n\n[isin(a, b), isin(b, a)]\n\n# output\n\n2-element Vector{Bool}:\n true\n false\n```\n\nNote\n\nAt this point there are 2 layers of linear search so the time complexity is n^2.\n\nSee Also GenomePermutations.isin, GenomePermutations.anyin.\n\n\n\n\n\n","category":"method"},{"location":"#GenomePermutations.isin-Union{Tuple{T}, Tuple{S}, Tuple{Interval{S}, IntervalCollection{T}}} where {S, T}","page":"Home","title":"GenomePermutations.isin","text":"isin(a::GenomicFeatures.Interval{T}, b::GenomicFeatures.IntervalCollection{S})\n\nLinearly check if interval a is fully contained in any interval of collection b.\n\nusing GenomicFeatures \na = GenomicFeatures.Interval(\"chr1\", 5, 10)\nb = GenomicFeatures.IntervalCollection([\n\tGenomicFeatures.Interval(\"chr1\", 5, 10),\n\tGenomicFeatures.Interval(\"chr1\", 25, 35 ),\n\tGenomicFeatures.Interval(\"chr1\", 40, 65)\n\t])\n\nisin(a, b) \n\t\t\n# output\n\ntrue\n\nusing GenomicFeatures \na = GenomicFeatures.Interval(\"chr1\", 30, 50)\nb = GenomicFeatures.IntervalCollection([\n\tGenomicFeatures.Interval(\"chr1\", 5, 10),\n\tGenomicFeatures.Interval(\"chr1\", 25, 35),\n\tGenomicFeatures.Interval(\"chr1\", 35, 65)\n\t])\n\nisin(a, b) \n\t\t\n# output\n\nfalse\n\n#Note \n\nisin(a, b) strictly checks if a is contained in any single interval of b,  rather than whether a is contained within any combination of intervals in collection b\n\nSee Also GenomePermutations.isin, GenomePermutations.anyin.\n\n\n\n\n\n","category":"method"},{"location":"#GenomePermutations.isin-Union{Tuple{T}, Tuple{S}, Tuple{Interval{S}, Interval{T}}} where {S, T}","page":"Home","title":"GenomePermutations.isin","text":"isin(a::GenomicFeatures.Interval{S}, GenomicFeatures.Interval{T})\n\nCheck if interval a is fully contained in interval b.\n\nusing GenomicFeatures \na = GenomicFeatures.Interval(\"chr1\", 5, 10)\nb = GenomicFeatures.Interval(\"chr1\", 1, 15)\n\nisin(a, b) \n\t\n# output\n\ntrue\n\nusing GenomicFeatures \na = GenomicFeatures.Interval(\"chr1\", 20, 30)\nb = GenomicFeatures.Interval(\"chr1\", 1, 15)\n\nisin(a, b) \n\t\n# output\n\nfalse\n\nusing GenomicFeatures \na = GenomicFeatures.Interval(\"chr1\", 10, 20)\nb = GenomicFeatures.Interval(\"chr1\", 1, 15)\n\nisin(a, b) \n\t\n# output\n\nfalse\n\nSee Also GenomePermutations.isin, GenomePermutations.anyin.\n\n\n\n\n\n","category":"method"},{"location":"#GenomePermutations.iter_getcollection-Union{Tuple{T}, Tuple{IntervalCollection{T}, String}} where T","page":"Home","title":"GenomePermutations.iter_getcollection","text":"iter_getcollection(collection::GenomicFeatures.IntervalCollection{T}, sequence::String)\n\n(inefficiently) retun a interval collection with only features in the specified sequence. There should be a better way to do this.\n\nsee also GenomePermutations.vec_getcollection\n\n\n\n\n\n","category":"method"},{"location":"#GenomePermutations.overlappermtest-NTuple{4, Any}","page":"Home","title":"GenomePermutations.overlappermtest","text":"overlappermtest(col1, col2, regions, iterations; bed_names, allow_overlap = false,\nmax_tries = 1000, onfail = :throws)\n\nLegacy function to run an overlap permutation test across 2 regions. will be replaced by permtest using countoverlapping as f argument. Will need a g function to summarise overlaps across regions. (likely sum).\n\nArguments\n\ncol1::GenomicFeatures.IntervalCollection{T}: the collection to randomise.\ncol2::GenomicFeatures.IntervalCollection{S}: the constant collection to test.\nregions::GenomicFeatures.IntervalCollection{S}: the regions col1 is randomised in.\niterations::Int: the number of iterations to run.\nbed_names::Union{String, Nothing}: the names of the bed files to write to.\nallow_overlap::Bool = false: whether to allow overlaps in the randomised regions.\nmax_tries::Int: the maximum number of tries to generate a randomised collection.\nonfail::Symbol = :throw: what to do if a random interval fails to fit in the region.\n\nWill return the orignal interval if :orig, skip the interval if :skip, otherwise throws an error.\n\n\n\n\n\n","category":"method"},{"location":"#GenomePermutations.permtest","page":"Home","title":"GenomePermutations.permtest","text":"permtest(col1, col2, regions, iterations, f; allow_overlap = false, max_tries::Int = 1000, onfail = :throw)\n\nRuns a flexible permuation test, using a custsom evaluation function f.\n\nArguments\n\ncol1::GenomicFeatures.IntervalCollection{}: the collection to randomise.\ncol2::GenomicFeatures.IntervalCollection{}: the constant collection to test.\nregions::GenomicFeatures.IntervalCollection{}: the regions col1 is randomised in.\niterations::Int: the number of iterations to run.\nf::Function = GenomePermutations.dist: the evaluation function. \n\nDefaults to GenomePermutations.dist.\n\nbed_names::Union{String, Nothing}: the names of the bed files to write to.\nallow_overlap::Bool = false: whether to allow overlaps in the randomised regions.\nmax_tries::Int = 1000: the maximum number of tries to generate a randomised collection.\nonfail::Symbol = :throw: what to do if a random interval fails to fit in the region.\n\nWill return the orignal interval if :orig, skips it if :skip, otherwise throws an error.\n\n\n\n\n\n","category":"function"},{"location":"#GenomePermutations.randominterval-Union{Tuple{T}, Tuple{S}, Tuple{Interval{T}, Distributions.Sampleable, IntervalCollection{S}}} where {S, T}","page":"Home","title":"GenomePermutations.randominterval","text":"randominterval(interval, distribution, regions, collection; allow_overlap, max_tries, onfail)\n\nRandomises the position of an interval according to a given distribution. \n\nArguments\n\ninterval::GenomicFeatures.IntervalCollection: The interval to randomise\ndistribution::Distributions.Sampleable: distribution of possible interval start location.\n\nShould be a discrete distribution, although right now this is not enforced at the signature level\n\nregions::: the regions the new interval should be fully contained in (checked byisin)\ncollecton::GenomicFeatures.IntervalCollection =  GenomicFeatures.IntervalCollection{T}(): Collection to avoid overlapping \n\nto if allow_overlap is set to false, defaults to an empty collection of metadata .\n\nallow_overlap::Bool = true: whether to allow overlaps to collection.\nmax_tries::Int = 1000: the maximum number of attempts to draw an interval that fits in\n\nthe region from the distribution\n\nonfail::Symbol = :throw: what to do if the interval fails to fit in the region.\n\nWill return the orignal interval if :orig, returns nothing if :skip or throw an error if :throw.\n\nNote\n\nTo prevent intervals in a loop from overlapping each other, use  allow_overlap = false and add the result of each iteration to the collection paseed to the function.\n\nSee Also (_randominterval)[@ref]\n\n\n\n\n\n","category":"method"},{"location":"#GenomePermutations.randomisegenome-Union{Tuple{T}, Tuple{S}, Tuple{IntervalCollection{T}, IntervalCollection{S}}} where {S, T}","page":"Home","title":"GenomePermutations.randomisegenome","text":"randomisegenome(col, regions; allow_overlap, max_tries)\n\nRandomises a collection, sequence by sequence along the specified regions, returning the new collection\n\nrguments\n\ncol::GenomicFeatrues.IntervalCollection{T}: collection to randomise\nregions::GenomicFeatures.IntervalCollection{S}: regions to randomise the collection in.\nallow_overlap::Bool = false: whether to allow overlapping intervals in the result.\nmax_tries::Int = 1000: maximum number of attempts to draw an interval\n\nthat fits in the regions.\n\nonfail::Symbol = :throw: what to do if an interval fails to fit in the regions.\n\nWill return the orignal interval if :orig, skip the interval if :skip, otherwise throws an error.\n\nNote: it will skip any sequences in the collection not found in the target regions. If no sequences are found returns an empty collection.\n\n\n\n\n\n","category":"method"},{"location":"#GenomePermutations.randomiseregions-Union{Tuple{S}, Tuple{T}, Tuple{IntervalCollection{T}, Distributions.Sampleable, IntervalCollection{S}}} where {T, S}","page":"Home","title":"GenomePermutations.randomiseregions","text":"randomiseregions(collection, distribution, regions; allow_overlap, max_tries, onfail)\n\nGenerates randomised regions from an interval collection according to a start postion distribution. It guarantees that the new intervals are contained in the given regions.\n\nArguments\n\ncollection::GenomicFeatures.IntervalCollection{T}: collection to randomise,\n\nmust have only 1 sequence.\n\ndistribution::Distributions.Sampleable: distribution of possible interval\n\nstart locations, must match collection.\n\nregions::GenomicFeatures.IntervalCollection{S}: regions to randomise the intervals in.\n`allow_overlap::Bool = false.\nmax_tries::Int = 1000: maximum number of attempts to draw an interval\n\nthat fits in the region from the distribution.\n\nonfail::Symbol = :throw: what to do if an interval fails to fit in the region.\n\nWill return the orignal interval if :orig, skip the interval if :skip, otherwise throws an error.\n\nNotes\n\nthis functions assumes that the interval collection contains intervals belonging  to a single sequence that is the same sequence used for the distribution.  The distribution should be derived from the regions. If the distribution and the regions don't match it will most likely fail safely New intervals overlapping with other intervals in the nascient collection are disallowed by default. To allow overlaps use `allow_overlap = true\n\n\n\n\n\n","category":"method"},{"location":"#GenomePermutations.simpleP-Tuple{Any, Any, Any}","page":"Home","title":"GenomePermutations.simpleP","text":"simpleP(obs, ran, iterations; alternative :Auto)\n\nCalculates the p value for the alternative hypothesis that the observed value is either more or less than what we expect from the Vecor of random values.\n\nIf no altrantive is provided, will be automatically selected  on the basis of the data.\n\nSee also: regioneR, SimplePTest Please see regioneR for full details\n\n\n\n\n\n","category":"method"},{"location":"#GenomePermutations.vec_getcollection-Tuple{Any, String}","page":"Home","title":"GenomePermutations.vec_getcollection","text":"vec_getcollection(collection::GenomicFeatures.IntervalCollection{T}, sequence::String)\n\n(inefficiently) retun a interval collection with only features in the specified sequence. There should be a better way to do this.\n\nSee Also GenomePermutations.iter_getcollection\n\n\n\n\n\n","category":"method"},{"location":"#HypothesisTests.pvalue-Tuple{PermTestResult}","page":"Home","title":"HypothesisTests.pvalue","text":"HypothesisTests.pvalue(test::GenomePermutations.PermTestResult)\n\nExtends HypothesisTests.pvalue to get the P value of a GenomePermutations.PermTestResult.\n\n\n\n\n\n","category":"method"},{"location":"#HypothesisTests.pvalue-Tuple{SimplePTest}","page":"Home","title":"HypothesisTests.pvalue","text":"HypothesisTests.pvalue(test::GenomePermutations.SimplePTest)\n\nExtends HypothesisTests.pvalue to get the P value of a GenomePermutations.SimplePTest.\n\n\n\n\n\n","category":"method"}]
}
